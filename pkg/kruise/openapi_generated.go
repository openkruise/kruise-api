//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright 2024 The Kruise Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by openapi-gen. DO NOT EDIT.

package kruise

import (
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	common "k8s.io/kube-openapi/pkg/common"
	spec "k8s.io/kube-openapi/pkg/validation/spec"
)

func GetOpenAPIDefinitions(ref common.ReferenceCallback) map[string]common.OpenAPIDefinition {
	return map[string]common.OpenAPIDefinition{
		"github.com/openkruise/kruise-api/apps/pub.InPlaceUpdateContainerBatch":                         schema_openkruise_kruise_api_apps_pub_InPlaceUpdateContainerBatch(ref),
		"github.com/openkruise/kruise-api/apps/pub.InPlaceUpdateContainerStatus":                        schema_openkruise_kruise_api_apps_pub_InPlaceUpdateContainerStatus(ref),
		"github.com/openkruise/kruise-api/apps/pub.InPlaceUpdatePreCheckBeforeNext":                     schema_openkruise_kruise_api_apps_pub_InPlaceUpdatePreCheckBeforeNext(ref),
		"github.com/openkruise/kruise-api/apps/pub.InPlaceUpdateState":                                  schema_openkruise_kruise_api_apps_pub_InPlaceUpdateState(ref),
		"github.com/openkruise/kruise-api/apps/pub.InPlaceUpdateStrategy":                               schema_openkruise_kruise_api_apps_pub_InPlaceUpdateStrategy(ref),
		"github.com/openkruise/kruise-api/apps/pub.Lifecycle":                                           schema_openkruise_kruise_api_apps_pub_Lifecycle(ref),
		"github.com/openkruise/kruise-api/apps/pub.LifecycleHook":                                       schema_openkruise_kruise_api_apps_pub_LifecycleHook(ref),
		"github.com/openkruise/kruise-api/apps/pub.RuntimeContainerHashes":                              schema_openkruise_kruise_api_apps_pub_RuntimeContainerHashes(ref),
		"github.com/openkruise/kruise-api/apps/pub.RuntimeContainerMeta":                                schema_openkruise_kruise_api_apps_pub_RuntimeContainerMeta(ref),
		"github.com/openkruise/kruise-api/apps/pub.RuntimeContainerMetaSet":                             schema_openkruise_kruise_api_apps_pub_RuntimeContainerMetaSet(ref),
		"github.com/openkruise/kruise-api/apps/pub.UpdatePriorityOrderTerm":                             schema_openkruise_kruise_api_apps_pub_UpdatePriorityOrderTerm(ref),
		"github.com/openkruise/kruise-api/apps/pub.UpdatePriorityStrategy":                              schema_openkruise_kruise_api_apps_pub_UpdatePriorityStrategy(ref),
		"github.com/openkruise/kruise-api/apps/pub.UpdatePriorityWeightTerm":                            schema_openkruise_kruise_api_apps_pub_UpdatePriorityWeightTerm(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.AdaptiveUnitedDeploymentStrategy":               schema_openkruise_kruise_api_apps_v1alpha1_AdaptiveUnitedDeploymentStrategy(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.AdaptiveWorkloadSpreadStrategy":                 schema_openkruise_kruise_api_apps_v1alpha1_AdaptiveWorkloadSpreadStrategy(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.AdvancedCronJob":                                schema_openkruise_kruise_api_apps_v1alpha1_AdvancedCronJob(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.AdvancedCronJobList":                            schema_openkruise_kruise_api_apps_v1alpha1_AdvancedCronJobList(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.AdvancedCronJobSpec":                            schema_openkruise_kruise_api_apps_v1alpha1_AdvancedCronJobSpec(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.AdvancedCronJobStatus":                          schema_openkruise_kruise_api_apps_v1alpha1_AdvancedCronJobStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.AdvancedStatefulSetTemplateSpec":                schema_openkruise_kruise_api_apps_v1alpha1_AdvancedStatefulSetTemplateSpec(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.BroadcastJob":                                   schema_openkruise_kruise_api_apps_v1alpha1_BroadcastJob(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.BroadcastJobList":                               schema_openkruise_kruise_api_apps_v1alpha1_BroadcastJobList(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.BroadcastJobSpec":                               schema_openkruise_kruise_api_apps_v1alpha1_BroadcastJobSpec(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.BroadcastJobStatus":                             schema_openkruise_kruise_api_apps_v1alpha1_BroadcastJobStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.BroadcastJobTemplateSpec":                       schema_openkruise_kruise_api_apps_v1alpha1_BroadcastJobTemplateSpec(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.CloneSet":                                       schema_openkruise_kruise_api_apps_v1alpha1_CloneSet(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.CloneSetCondition":                              schema_openkruise_kruise_api_apps_v1alpha1_CloneSetCondition(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.CloneSetList":                                   schema_openkruise_kruise_api_apps_v1alpha1_CloneSetList(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.CloneSetScaleStrategy":                          schema_openkruise_kruise_api_apps_v1alpha1_CloneSetScaleStrategy(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.CloneSetSpec":                                   schema_openkruise_kruise_api_apps_v1alpha1_CloneSetSpec(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.CloneSetStatus":                                 schema_openkruise_kruise_api_apps_v1alpha1_CloneSetStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.CloneSetTemplateSpec":                           schema_openkruise_kruise_api_apps_v1alpha1_CloneSetTemplateSpec(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.CloneSetUpdateStrategy":                         schema_openkruise_kruise_api_apps_v1alpha1_CloneSetUpdateStrategy(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.CompletionPolicy":                               schema_openkruise_kruise_api_apps_v1alpha1_CompletionPolicy(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ContainerProbe":                                 schema_openkruise_kruise_api_apps_v1alpha1_ContainerProbe(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ContainerProbeSpec":                             schema_openkruise_kruise_api_apps_v1alpha1_ContainerProbeSpec(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ContainerProbeState":                            schema_openkruise_kruise_api_apps_v1alpha1_ContainerProbeState(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ContainerRecreateRequest":                       schema_openkruise_kruise_api_apps_v1alpha1_ContainerRecreateRequest(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ContainerRecreateRequestContainer":              schema_openkruise_kruise_api_apps_v1alpha1_ContainerRecreateRequestContainer(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ContainerRecreateRequestContainerContext":       schema_openkruise_kruise_api_apps_v1alpha1_ContainerRecreateRequestContainerContext(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ContainerRecreateRequestContainerRecreateState": schema_openkruise_kruise_api_apps_v1alpha1_ContainerRecreateRequestContainerRecreateState(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ContainerRecreateRequestList":                   schema_openkruise_kruise_api_apps_v1alpha1_ContainerRecreateRequestList(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ContainerRecreateRequestSpec":                   schema_openkruise_kruise_api_apps_v1alpha1_ContainerRecreateRequestSpec(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ContainerRecreateRequestStatus":                 schema_openkruise_kruise_api_apps_v1alpha1_ContainerRecreateRequestStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ContainerRecreateRequestStrategy":               schema_openkruise_kruise_api_apps_v1alpha1_ContainerRecreateRequestStrategy(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ContainerRecreateRequestSyncContainerStatus":    schema_openkruise_kruise_api_apps_v1alpha1_ContainerRecreateRequestSyncContainerStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.CronJobTemplate":                                schema_openkruise_kruise_api_apps_v1alpha1_CronJobTemplate(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.DaemonSet":                                      schema_openkruise_kruise_api_apps_v1alpha1_DaemonSet(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.DaemonSetList":                                  schema_openkruise_kruise_api_apps_v1alpha1_DaemonSetList(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.DaemonSetSpec":                                  schema_openkruise_kruise_api_apps_v1alpha1_DaemonSetSpec(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.DaemonSetStatus":                                schema_openkruise_kruise_api_apps_v1alpha1_DaemonSetStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.DaemonSetUpdateStrategy":                        schema_openkruise_kruise_api_apps_v1alpha1_DaemonSetUpdateStrategy(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.DeploymentTemplateSpec":                         schema_openkruise_kruise_api_apps_v1alpha1_DeploymentTemplateSpec(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.EphemeralContainerTemplateSpec":                 schema_openkruise_kruise_api_apps_v1alpha1_EphemeralContainerTemplateSpec(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.EphemeralJob":                                   schema_openkruise_kruise_api_apps_v1alpha1_EphemeralJob(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.EphemeralJobCondition":                          schema_openkruise_kruise_api_apps_v1alpha1_EphemeralJobCondition(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.EphemeralJobList":                               schema_openkruise_kruise_api_apps_v1alpha1_EphemeralJobList(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.EphemeralJobSpec":                               schema_openkruise_kruise_api_apps_v1alpha1_EphemeralJobSpec(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.EphemeralJobStatus":                             schema_openkruise_kruise_api_apps_v1alpha1_EphemeralJobStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.FailedImageStatus":                              schema_openkruise_kruise_api_apps_v1alpha1_FailedImageStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.FailurePolicy":                                  schema_openkruise_kruise_api_apps_v1alpha1_FailurePolicy(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ImageListPullJob":                               schema_openkruise_kruise_api_apps_v1alpha1_ImageListPullJob(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ImageListPullJobList":                           schema_openkruise_kruise_api_apps_v1alpha1_ImageListPullJobList(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ImageListPullJobSpec":                           schema_openkruise_kruise_api_apps_v1alpha1_ImageListPullJobSpec(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ImageListPullJobStatus":                         schema_openkruise_kruise_api_apps_v1alpha1_ImageListPullJobStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ImagePullJob":                                   schema_openkruise_kruise_api_apps_v1alpha1_ImagePullJob(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ImagePullJobList":                               schema_openkruise_kruise_api_apps_v1alpha1_ImagePullJobList(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ImagePullJobNodeSelector":                       schema_openkruise_kruise_api_apps_v1alpha1_ImagePullJobNodeSelector(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ImagePullJobPodSelector":                        schema_openkruise_kruise_api_apps_v1alpha1_ImagePullJobPodSelector(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ImagePullJobSpec":                               schema_openkruise_kruise_api_apps_v1alpha1_ImagePullJobSpec(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ImagePullJobStatus":                             schema_openkruise_kruise_api_apps_v1alpha1_ImagePullJobStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ImagePullJobTemplate":                           schema_openkruise_kruise_api_apps_v1alpha1_ImagePullJobTemplate(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ImageSpec":                                      schema_openkruise_kruise_api_apps_v1alpha1_ImageSpec(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ImageStatus":                                    schema_openkruise_kruise_api_apps_v1alpha1_ImageStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ImageTagPullPolicy":                             schema_openkruise_kruise_api_apps_v1alpha1_ImageTagPullPolicy(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ImageTagSpec":                                   schema_openkruise_kruise_api_apps_v1alpha1_ImageTagSpec(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ImageTagStatus":                                 schema_openkruise_kruise_api_apps_v1alpha1_ImageTagStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.JobCondition":                                   schema_openkruise_kruise_api_apps_v1alpha1_JobCondition(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ManualUpdate":                                   schema_openkruise_kruise_api_apps_v1alpha1_ManualUpdate(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.NodeImage":                                      schema_openkruise_kruise_api_apps_v1alpha1_NodeImage(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.NodeImageList":                                  schema_openkruise_kruise_api_apps_v1alpha1_NodeImageList(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.NodeImageSpec":                                  schema_openkruise_kruise_api_apps_v1alpha1_NodeImageSpec(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.NodeImageStatus":                                schema_openkruise_kruise_api_apps_v1alpha1_NodeImageStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.NodePodProbe":                                   schema_openkruise_kruise_api_apps_v1alpha1_NodePodProbe(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.NodePodProbeList":                               schema_openkruise_kruise_api_apps_v1alpha1_NodePodProbeList(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.NodePodProbeSpec":                               schema_openkruise_kruise_api_apps_v1alpha1_NodePodProbeSpec(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.NodePodProbeStatus":                             schema_openkruise_kruise_api_apps_v1alpha1_NodePodProbeStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.NodeTopologyTerm":                               schema_openkruise_kruise_api_apps_v1alpha1_NodeTopologyTerm(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.PersistentPodAnnotation":                        schema_openkruise_kruise_api_apps_v1alpha1_PersistentPodAnnotation(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.PersistentPodState":                             schema_openkruise_kruise_api_apps_v1alpha1_PersistentPodState(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.PersistentPodStateList":                         schema_openkruise_kruise_api_apps_v1alpha1_PersistentPodStateList(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.PersistentPodStateSpec":                         schema_openkruise_kruise_api_apps_v1alpha1_PersistentPodStateSpec(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.PersistentPodStateStatus":                       schema_openkruise_kruise_api_apps_v1alpha1_PersistentPodStateStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.PodContainerProbe":                              schema_openkruise_kruise_api_apps_v1alpha1_PodContainerProbe(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.PodProbe":                                       schema_openkruise_kruise_api_apps_v1alpha1_PodProbe(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.PodProbeMarker":                                 schema_openkruise_kruise_api_apps_v1alpha1_PodProbeMarker(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.PodProbeMarkerList":                             schema_openkruise_kruise_api_apps_v1alpha1_PodProbeMarkerList(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.PodProbeMarkerSpec":                             schema_openkruise_kruise_api_apps_v1alpha1_PodProbeMarkerSpec(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.PodProbeMarkerStatus":                           schema_openkruise_kruise_api_apps_v1alpha1_PodProbeMarkerStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.PodProbeStatus":                                 schema_openkruise_kruise_api_apps_v1alpha1_PodProbeStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.PodState":                                       schema_openkruise_kruise_api_apps_v1alpha1_PodState(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.PreferredTopologyTerm":                          schema_openkruise_kruise_api_apps_v1alpha1_PreferredTopologyTerm(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ProbeHandler":                                   schema_openkruise_kruise_api_apps_v1alpha1_ProbeHandler(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ProbeMarkerPolicy":                              schema_openkruise_kruise_api_apps_v1alpha1_ProbeMarkerPolicy(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.PullPolicy":                                     schema_openkruise_kruise_api_apps_v1alpha1_PullPolicy(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ReferenceObject":                                schema_openkruise_kruise_api_apps_v1alpha1_ReferenceObject(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ResourceDistribution":                           schema_openkruise_kruise_api_apps_v1alpha1_ResourceDistribution(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ResourceDistributionCondition":                  schema_openkruise_kruise_api_apps_v1alpha1_ResourceDistributionCondition(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ResourceDistributionList":                       schema_openkruise_kruise_api_apps_v1alpha1_ResourceDistributionList(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ResourceDistributionNamespace":                  schema_openkruise_kruise_api_apps_v1alpha1_ResourceDistributionNamespace(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ResourceDistributionSpec":                       schema_openkruise_kruise_api_apps_v1alpha1_ResourceDistributionSpec(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ResourceDistributionStatus":                     schema_openkruise_kruise_api_apps_v1alpha1_ResourceDistributionStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ResourceDistributionTargetNamespaces":           schema_openkruise_kruise_api_apps_v1alpha1_ResourceDistributionTargetNamespaces(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ResourceDistributionTargets":                    schema_openkruise_kruise_api_apps_v1alpha1_ResourceDistributionTargets(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.RollingUpdateDaemonSet":                         schema_openkruise_kruise_api_apps_v1alpha1_RollingUpdateDaemonSet(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.RollingUpdateStatefulSetStrategy":               schema_openkruise_kruise_api_apps_v1alpha1_RollingUpdateStatefulSetStrategy(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.SandboxConfig":                                  schema_openkruise_kruise_api_apps_v1alpha1_SandboxConfig(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.ShareVolumePolicy":                              schema_openkruise_kruise_api_apps_v1alpha1_ShareVolumePolicy(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.SidecarContainer":                               schema_openkruise_kruise_api_apps_v1alpha1_SidecarContainer(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.SidecarContainerUpgradeStrategy":                schema_openkruise_kruise_api_apps_v1alpha1_SidecarContainerUpgradeStrategy(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.SidecarSet":                                     schema_openkruise_kruise_api_apps_v1alpha1_SidecarSet(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.SidecarSetInjectRevision":                       schema_openkruise_kruise_api_apps_v1alpha1_SidecarSetInjectRevision(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.SidecarSetInjectionStrategy":                    schema_openkruise_kruise_api_apps_v1alpha1_SidecarSetInjectionStrategy(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.SidecarSetList":                                 schema_openkruise_kruise_api_apps_v1alpha1_SidecarSetList(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.SidecarSetPatchPodMetadata":                     schema_openkruise_kruise_api_apps_v1alpha1_SidecarSetPatchPodMetadata(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.SidecarSetSpec":                                 schema_openkruise_kruise_api_apps_v1alpha1_SidecarSetSpec(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.SidecarSetStatus":                               schema_openkruise_kruise_api_apps_v1alpha1_SidecarSetStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.SidecarSetUpdateStrategy":                       schema_openkruise_kruise_api_apps_v1alpha1_SidecarSetUpdateStrategy(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.SourceContainerNameSource":                      schema_openkruise_kruise_api_apps_v1alpha1_SourceContainerNameSource(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.StatefulSet":                                    schema_openkruise_kruise_api_apps_v1alpha1_StatefulSet(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.StatefulSetList":                                schema_openkruise_kruise_api_apps_v1alpha1_StatefulSetList(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.StatefulSetSpec":                                schema_openkruise_kruise_api_apps_v1alpha1_StatefulSetSpec(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.StatefulSetStatus":                              schema_openkruise_kruise_api_apps_v1alpha1_StatefulSetStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.StatefulSetTemplateSpec":                        schema_openkruise_kruise_api_apps_v1alpha1_StatefulSetTemplateSpec(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.StatefulSetUpdateStrategy":                      schema_openkruise_kruise_api_apps_v1alpha1_StatefulSetUpdateStrategy(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.Subset":                                         schema_openkruise_kruise_api_apps_v1alpha1_Subset(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.SubsetTemplate":                                 schema_openkruise_kruise_api_apps_v1alpha1_SubsetTemplate(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.SyncStatus":                                     schema_openkruise_kruise_api_apps_v1alpha1_SyncStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.TargetFilter":                                   schema_openkruise_kruise_api_apps_v1alpha1_TargetFilter(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.TargetReference":                                schema_openkruise_kruise_api_apps_v1alpha1_TargetReference(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.Topology":                                       schema_openkruise_kruise_api_apps_v1alpha1_Topology(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.TransferEnvVar":                                 schema_openkruise_kruise_api_apps_v1alpha1_TransferEnvVar(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.UnitedDeployment":                               schema_openkruise_kruise_api_apps_v1alpha1_UnitedDeployment(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.UnitedDeploymentCondition":                      schema_openkruise_kruise_api_apps_v1alpha1_UnitedDeploymentCondition(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.UnitedDeploymentList":                           schema_openkruise_kruise_api_apps_v1alpha1_UnitedDeploymentList(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.UnitedDeploymentScheduleStrategy":               schema_openkruise_kruise_api_apps_v1alpha1_UnitedDeploymentScheduleStrategy(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.UnitedDeploymentSpec":                           schema_openkruise_kruise_api_apps_v1alpha1_UnitedDeploymentSpec(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.UnitedDeploymentStatus":                         schema_openkruise_kruise_api_apps_v1alpha1_UnitedDeploymentStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.UnitedDeploymentSubsetCondition":                schema_openkruise_kruise_api_apps_v1alpha1_UnitedDeploymentSubsetCondition(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.UnitedDeploymentSubsetStatus":                   schema_openkruise_kruise_api_apps_v1alpha1_UnitedDeploymentSubsetStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.UnitedDeploymentUpdateStrategy":                 schema_openkruise_kruise_api_apps_v1alpha1_UnitedDeploymentUpdateStrategy(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.UnorderedUpdateStrategy":                        schema_openkruise_kruise_api_apps_v1alpha1_UnorderedUpdateStrategy(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.UpdateScatterTerm":                              schema_openkruise_kruise_api_apps_v1alpha1_UpdateScatterTerm(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.UpdateStatus":                                   schema_openkruise_kruise_api_apps_v1alpha1_UpdateStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.WorkloadSpread":                                 schema_openkruise_kruise_api_apps_v1alpha1_WorkloadSpread(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.WorkloadSpreadList":                             schema_openkruise_kruise_api_apps_v1alpha1_WorkloadSpreadList(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.WorkloadSpreadScheduleStrategy":                 schema_openkruise_kruise_api_apps_v1alpha1_WorkloadSpreadScheduleStrategy(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.WorkloadSpreadSpec":                             schema_openkruise_kruise_api_apps_v1alpha1_WorkloadSpreadSpec(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.WorkloadSpreadStatus":                           schema_openkruise_kruise_api_apps_v1alpha1_WorkloadSpreadStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.WorkloadSpreadSubset":                           schema_openkruise_kruise_api_apps_v1alpha1_WorkloadSpreadSubset(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.WorkloadSpreadSubsetCondition":                  schema_openkruise_kruise_api_apps_v1alpha1_WorkloadSpreadSubsetCondition(ref),
		"github.com/openkruise/kruise-api/apps/v1alpha1.WorkloadSpreadSubsetStatus":                     schema_openkruise_kruise_api_apps_v1alpha1_WorkloadSpreadSubsetStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1beta1.RollingUpdateStatefulSetStrategy":                schema_openkruise_kruise_api_apps_v1beta1_RollingUpdateStatefulSetStrategy(ref),
		"github.com/openkruise/kruise-api/apps/v1beta1.StatefulSet":                                     schema_openkruise_kruise_api_apps_v1beta1_StatefulSet(ref),
		"github.com/openkruise/kruise-api/apps/v1beta1.StatefulSetList":                                 schema_openkruise_kruise_api_apps_v1beta1_StatefulSetList(ref),
		"github.com/openkruise/kruise-api/apps/v1beta1.StatefulSetOrdinals":                             schema_openkruise_kruise_api_apps_v1beta1_StatefulSetOrdinals(ref),
		"github.com/openkruise/kruise-api/apps/v1beta1.StatefulSetPersistentVolumeClaimRetentionPolicy": schema_openkruise_kruise_api_apps_v1beta1_StatefulSetPersistentVolumeClaimRetentionPolicy(ref),
		"github.com/openkruise/kruise-api/apps/v1beta1.StatefulSetScaleStrategy":                        schema_openkruise_kruise_api_apps_v1beta1_StatefulSetScaleStrategy(ref),
		"github.com/openkruise/kruise-api/apps/v1beta1.StatefulSetSpec":                                 schema_openkruise_kruise_api_apps_v1beta1_StatefulSetSpec(ref),
		"github.com/openkruise/kruise-api/apps/v1beta1.StatefulSetStatus":                               schema_openkruise_kruise_api_apps_v1beta1_StatefulSetStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1beta1.StatefulSetUpdateStrategy":                       schema_openkruise_kruise_api_apps_v1beta1_StatefulSetUpdateStrategy(ref),
		"github.com/openkruise/kruise-api/apps/v1beta1.UnorderedUpdateStrategy":                         schema_openkruise_kruise_api_apps_v1beta1_UnorderedUpdateStrategy(ref),
		"github.com/openkruise/kruise-api/apps/v1beta1.VolumeClaimStatus":                               schema_openkruise_kruise_api_apps_v1beta1_VolumeClaimStatus(ref),
		"github.com/openkruise/kruise-api/apps/v1beta1.VolumeClaimUpdateStrategy":                       schema_openkruise_kruise_api_apps_v1beta1_VolumeClaimUpdateStrategy(ref),
		"github.com/openkruise/kruise-api/policy/v1alpha1.PodUnavailableBudget":                         schema_openkruise_kruise_api_policy_v1alpha1_PodUnavailableBudget(ref),
		"github.com/openkruise/kruise-api/policy/v1alpha1.PodUnavailableBudgetList":                     schema_openkruise_kruise_api_policy_v1alpha1_PodUnavailableBudgetList(ref),
		"github.com/openkruise/kruise-api/policy/v1alpha1.PodUnavailableBudgetSpec":                     schema_openkruise_kruise_api_policy_v1alpha1_PodUnavailableBudgetSpec(ref),
		"github.com/openkruise/kruise-api/policy/v1alpha1.PodUnavailableBudgetStatus":                   schema_openkruise_kruise_api_policy_v1alpha1_PodUnavailableBudgetStatus(ref),
		"github.com/openkruise/kruise-api/policy/v1alpha1.TargetReference":                              schema_openkruise_kruise_api_policy_v1alpha1_TargetReference(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.APIGroup":                                                 schema_pkg_apis_meta_v1_APIGroup(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.APIGroupList":                                             schema_pkg_apis_meta_v1_APIGroupList(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.APIResource":                                              schema_pkg_apis_meta_v1_APIResource(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.APIResourceList":                                          schema_pkg_apis_meta_v1_APIResourceList(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.APIVersions":                                              schema_pkg_apis_meta_v1_APIVersions(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.ApplyOptions":                                             schema_pkg_apis_meta_v1_ApplyOptions(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.Condition":                                                schema_pkg_apis_meta_v1_Condition(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.CreateOptions":                                            schema_pkg_apis_meta_v1_CreateOptions(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.DeleteOptions":                                            schema_pkg_apis_meta_v1_DeleteOptions(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.Duration":                                                 schema_pkg_apis_meta_v1_Duration(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.FieldsV1":                                                 schema_pkg_apis_meta_v1_FieldsV1(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.GetOptions":                                               schema_pkg_apis_meta_v1_GetOptions(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.GroupKind":                                                schema_pkg_apis_meta_v1_GroupKind(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.GroupResource":                                            schema_pkg_apis_meta_v1_GroupResource(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.GroupVersion":                                             schema_pkg_apis_meta_v1_GroupVersion(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.GroupVersionForDiscovery":                                 schema_pkg_apis_meta_v1_GroupVersionForDiscovery(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.GroupVersionKind":                                         schema_pkg_apis_meta_v1_GroupVersionKind(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.GroupVersionResource":                                     schema_pkg_apis_meta_v1_GroupVersionResource(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.InternalEvent":                                            schema_pkg_apis_meta_v1_InternalEvent(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector":                                            schema_pkg_apis_meta_v1_LabelSelector(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelectorRequirement":                                 schema_pkg_apis_meta_v1_LabelSelectorRequirement(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.List":                                                     schema_pkg_apis_meta_v1_List(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta":                                                 schema_pkg_apis_meta_v1_ListMeta(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.ListOptions":                                              schema_pkg_apis_meta_v1_ListOptions(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.ManagedFieldsEntry":                                       schema_pkg_apis_meta_v1_ManagedFieldsEntry(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.MicroTime":                                                schema_pkg_apis_meta_v1_MicroTime(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta":                                               schema_pkg_apis_meta_v1_ObjectMeta(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.OwnerReference":                                           schema_pkg_apis_meta_v1_OwnerReference(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.PartialObjectMetadata":                                    schema_pkg_apis_meta_v1_PartialObjectMetadata(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.PartialObjectMetadataList":                                schema_pkg_apis_meta_v1_PartialObjectMetadataList(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.Patch":                                                    schema_pkg_apis_meta_v1_Patch(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.PatchOptions":                                             schema_pkg_apis_meta_v1_PatchOptions(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.Preconditions":                                            schema_pkg_apis_meta_v1_Preconditions(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.RootPaths":                                                schema_pkg_apis_meta_v1_RootPaths(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.ServerAddressByClientCIDR":                                schema_pkg_apis_meta_v1_ServerAddressByClientCIDR(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.Status":                                                   schema_pkg_apis_meta_v1_Status(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.StatusCause":                                              schema_pkg_apis_meta_v1_StatusCause(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.StatusDetails":                                            schema_pkg_apis_meta_v1_StatusDetails(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.Table":                                                    schema_pkg_apis_meta_v1_Table(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.TableColumnDefinition":                                    schema_pkg_apis_meta_v1_TableColumnDefinition(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.TableOptions":                                             schema_pkg_apis_meta_v1_TableOptions(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.TableRow":                                                 schema_pkg_apis_meta_v1_TableRow(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.TableRowCondition":                                        schema_pkg_apis_meta_v1_TableRowCondition(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.Time":                                                     schema_pkg_apis_meta_v1_Time(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.Timestamp":                                                schema_pkg_apis_meta_v1_Timestamp(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.TypeMeta":                                                 schema_pkg_apis_meta_v1_TypeMeta(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.UpdateOptions":                                            schema_pkg_apis_meta_v1_UpdateOptions(ref),
		"k8s.io/apimachinery/pkg/apis/meta/v1.WatchEvent":                                               schema_pkg_apis_meta_v1_WatchEvent(ref),
		"k8s.io/apimachinery/pkg/runtime.RawExtension":                                                  schema_k8sio_apimachinery_pkg_runtime_RawExtension(ref),
		"k8s.io/apimachinery/pkg/runtime.TypeMeta":                                                      schema_k8sio_apimachinery_pkg_runtime_TypeMeta(ref),
		"k8s.io/apimachinery/pkg/runtime.Unknown":                                                       schema_k8sio_apimachinery_pkg_runtime_Unknown(ref),
		"k8s.io/apimachinery/pkg/version.Info":                                                          schema_k8sio_apimachinery_pkg_version_Info(ref),
	}
}

func schema_openkruise_kruise_api_apps_pub_InPlaceUpdateContainerBatch(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "InPlaceUpdateContainerBatch indicates the timestamp and containers for a batch update",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"timestamp": {
						SchemaProps: spec.SchemaProps{
							Description: "Timestamp is the time for this update batch",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"containers": {
						SchemaProps: spec.SchemaProps{
							Description: "Containers is the name list of containers for this update batch",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
				Required: []string{"timestamp", "containers"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_openkruise_kruise_api_apps_pub_InPlaceUpdateContainerStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "InPlaceUpdateContainerStatus records the statuses of the container that are mainly used to determine whether the InPlaceUpdate is completed.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"imageID": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_pub_InPlaceUpdatePreCheckBeforeNext(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "InPlaceUpdatePreCheckBeforeNext contains the pre-check that must pass before the next containers can be in-place update.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"containersRequiredReady": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_pub_InPlaceUpdateState(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "InPlaceUpdateState records latest inplace-update state, including old statuses of containers.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"revision": {
						SchemaProps: spec.SchemaProps{
							Description: "Revision is the updated revision hash.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"updateTimestamp": {
						SchemaProps: spec.SchemaProps{
							Description: "UpdateTimestamp is the start time when the in-place update happens.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"lastContainerStatuses": {
						SchemaProps: spec.SchemaProps{
							Description: "LastContainerStatuses records the before-in-place-update container statuses. It is a map from ContainerName to InPlaceUpdateContainerStatus",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/pub.InPlaceUpdateContainerStatus"),
									},
								},
							},
						},
					},
					"updateEnvFromMetadata": {
						SchemaProps: spec.SchemaProps{
							Description: "UpdateEnvFromMetadata indicates there are envs from annotations/labels that should be in-place update.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"updateResources": {
						SchemaProps: spec.SchemaProps{
							Description: "UpdateResources indicates there are resources that should be in-place update.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"updateImages": {
						SchemaProps: spec.SchemaProps{
							Description: "UpdateImages indicates there are images that should be in-place update.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"nextContainerImages": {
						SchemaProps: spec.SchemaProps{
							Description: "NextContainerImages is the containers with lower priority that waiting for in-place update images in next batch.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"nextContainerRefMetadata": {
						SchemaProps: spec.SchemaProps{
							Description: "NextContainerRefMetadata is the containers with lower priority that waiting for in-place update labels/annotations in next batch.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
									},
								},
							},
						},
					},
					"nextContainerResources": {
						SchemaProps: spec.SchemaProps{
							Description: "NextContainerResources is the containers with lower priority that waiting for in-place update resources in next batch.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.ResourceRequirements"),
									},
								},
							},
						},
					},
					"preCheckBeforeNext": {
						SchemaProps: spec.SchemaProps{
							Description: "PreCheckBeforeNext is the pre-check that must pass before the next containers can be in-place update.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/pub.InPlaceUpdatePreCheckBeforeNext"),
						},
					},
					"containerBatchesRecord": {
						SchemaProps: spec.SchemaProps{
							Description: "ContainerBatchesRecord records the update batches that have patched in this revision.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/pub.InPlaceUpdateContainerBatch"),
									},
								},
							},
						},
					},
				},
				Required: []string{"revision", "updateTimestamp", "lastContainerStatuses"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/pub.InPlaceUpdateContainerBatch", "github.com/openkruise/kruise-api/apps/pub.InPlaceUpdateContainerStatus", "github.com/openkruise/kruise-api/apps/pub.InPlaceUpdatePreCheckBeforeNext", "k8s.io/api/core/v1.ResourceRequirements", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_openkruise_kruise_api_apps_pub_InPlaceUpdateStrategy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "InPlaceUpdateStrategy defines the strategies for in-place update.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"gracePeriodSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "GracePeriodSeconds is the timespan between set Pod status to not-ready and update images in Pod spec when in-place update a Pod.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_pub_Lifecycle(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Lifecycle contains the hooks for Pod lifecycle.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"preDelete": {
						SchemaProps: spec.SchemaProps{
							Description: "PreDelete is the hook before Pod to be deleted.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/pub.LifecycleHook"),
						},
					},
					"inPlaceUpdate": {
						SchemaProps: spec.SchemaProps{
							Description: "InPlaceUpdate is the hook before Pod to update and after Pod has been updated.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/pub.LifecycleHook"),
						},
					},
					"preNormal": {
						SchemaProps: spec.SchemaProps{
							Description: "PreNormal is the hook after Pod to be created and ready to be Normal.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/pub.LifecycleHook"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/pub.LifecycleHook"},
	}
}

func schema_openkruise_kruise_api_apps_pub_LifecycleHook(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"labelsHandler": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"finalizersHandler": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"markPodNotReady": {
						SchemaProps: spec.SchemaProps{
							Description: "MarkPodNotReady = true means: - Pod will be set to 'NotReady' at preparingDelete/preparingUpdate state. - Pod will be restored to 'Ready' at Updated state if it was set to 'NotReady' at preparingUpdate state. Currently, MarkPodNotReady only takes effect on InPlaceUpdate & PreDelete hook. Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_pub_RuntimeContainerHashes(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RuntimeContainerHashes contains the hashes of such container.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"plainHash": {
						SchemaProps: spec.SchemaProps{
							Description: "PlainHash is the hash that directly calculated from pod.spec.container[x]. Usually it is calculated by Kubelet and will be in annotation of each runtime container.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"plainHashWithoutResources": {
						SchemaProps: spec.SchemaProps{
							Description: "PlainHashWithoutResources is the hash that directly calculated from pod.spec.container[x] over fields with Resources field zero'd out. Usually it is calculated by Kubelet and will be in annotation of each runtime container.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"extractedEnvFromMetadataHash": {
						SchemaProps: spec.SchemaProps{
							Description: "ExtractedEnvFromMetadataHash is the hash that calculated from pod.spec.container[x], whose envs from annotations/labels have already been extracted to the real values.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
				},
				Required: []string{"plainHash", "plainHashWithoutResources"},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_pub_RuntimeContainerMeta(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RuntimeContainerMeta contains the meta data of a runtime container.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"containerID": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"restartCount": {
						SchemaProps: spec.SchemaProps{
							Default: 0,
							Type:    []string{"integer"},
							Format:  "int32",
						},
					},
					"hashes": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/pub.RuntimeContainerHashes"),
						},
					},
				},
				Required: []string{"name", "containerID", "restartCount", "hashes"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/pub.RuntimeContainerHashes"},
	}
}

func schema_openkruise_kruise_api_apps_pub_RuntimeContainerMetaSet(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RuntimeContainerMetaSet contains all the containers' meta of the Pod.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"containers": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/pub.RuntimeContainerMeta"),
									},
								},
							},
						},
					},
				},
				Required: []string{"containers"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/pub.RuntimeContainerMeta"},
	}
}

func schema_openkruise_kruise_api_apps_pub_UpdatePriorityOrderTerm(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "UpdatePriorityOrderTerm defines order priority.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"orderedKey": {
						SchemaProps: spec.SchemaProps{
							Description: "Calculate priority by value of this key. Values of this key, will be sorted by GetInt(val). GetInt method will find the last int in value, such as getting 5 in value '5', getting 10 in value 'sts-10'.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"orderedKey"},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_pub_UpdatePriorityStrategy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "UpdatePriorityStrategy is the strategy to define priority for pods update. Only one of orderPriority and weightPriority can be set.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"orderPriority": {
						SchemaProps: spec.SchemaProps{
							Description: "Order priority terms, pods will be sorted by the value of orderedKey. For example: ``` orderPriority: - orderedKey: key1 - orderedKey: key2 ``` First, all pods which have key1 in labels will be sorted by the value of key1. Then, the left pods which have no key1 but have key2 in labels will be sorted by the value of key2 and put behind those pods have key1.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/pub.UpdatePriorityOrderTerm"),
									},
								},
							},
						},
					},
					"weightPriority": {
						SchemaProps: spec.SchemaProps{
							Description: "Weight priority terms, pods will be sorted by the sum of all terms weight.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/pub.UpdatePriorityWeightTerm"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/pub.UpdatePriorityOrderTerm", "github.com/openkruise/kruise-api/apps/pub.UpdatePriorityWeightTerm"},
	}
}

func schema_openkruise_kruise_api_apps_pub_UpdatePriorityWeightTerm(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "UpdatePriorityWeightTerm defines weight priority.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"weight": {
						SchemaProps: spec.SchemaProps{
							Description: "Weight associated with matching the corresponding matchExpressions, in the range 1-100.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"matchSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "MatchSelector is used to select by pod's labels.",
							Default:     map[string]interface{}{},
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"),
						},
					},
				},
				Required: []string{"weight", "matchSelector"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_AdaptiveUnitedDeploymentStrategy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AdaptiveUnitedDeploymentStrategy is used to communicate parameters when Type is AdaptiveUnitedDeploymentScheduleStrategyType.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"rescheduleCriticalSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "RescheduleCriticalSeconds indicates how long controller will reschedule a schedule failed Pod to the subset that has redundant capacity after the subset where the Pod lives. If a Pod was scheduled failed and still in an unschedulabe status over RescheduleCriticalSeconds duration, the controller will reschedule it to a suitable subset. Default is 30 seconds.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"unschedulableLastSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "UnschedulableLastSeconds is used to set the number of seconds for a Subset to recover from an unschedulable state, with a default value of 300 seconds.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_AdaptiveWorkloadSpreadStrategy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AdaptiveWorkloadSpreadStrategy is used to communicate parameters when Type is AdaptiveWorkloadSpreadScheduleStrategyType.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"disableSimulationSchedule": {
						SchemaProps: spec.SchemaProps{
							Description: "DisableSimulationSchedule indicates whether to disable the feature of simulation schedule. Default is false. Webhook can take a simple general predicates to check whether Pod can be scheduled into this subset, but it just considers the Node resource and cannot replace scheduler to do richer predicates practically.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"rescheduleCriticalSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "RescheduleCriticalSeconds indicates how long controller will reschedule a schedule failed Pod to the subset that has redundant capacity after the subset where the Pod lives. If a Pod was scheduled failed and still in a unschedulabe status over RescheduleCriticalSeconds duration, the controller will reschedule it to a suitable subset.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_AdvancedCronJob(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AdvancedCronJob is the Schema for the advancedcronjobs API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.AdvancedCronJobSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.AdvancedCronJobStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.AdvancedCronJobSpec", "github.com/openkruise/kruise-api/apps/v1alpha1.AdvancedCronJobStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_AdvancedCronJobList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AdvancedCronJobList contains a list of AdvancedCronJob",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.AdvancedCronJob"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.AdvancedCronJob", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_AdvancedCronJobSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AdvancedCronJobSpec defines the desired state of AdvancedCronJob",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"schedule": {
						SchemaProps: spec.SchemaProps{
							Description: "The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"timeZone": {
						SchemaProps: spec.SchemaProps{
							Description: "The time zone name for the given schedule, see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones. If not specified, this will default to the time zone of the kruise-controller-manager process.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"startingDeadlineSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Optional deadline in seconds for starting the job if it misses scheduled time for any reason.  Missed jobs executions will be counted as failed ones.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"concurrencyPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies how to treat concurrent executions of a Job. Valid values are: - \"Allow\" (default): allows CronJobs to run concurrently; - \"Forbid\": forbids concurrent runs, skipping next run if previous run hasn't finished yet; - \"Replace\": cancels currently running job and replaces it with a new one",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"paused": {
						SchemaProps: spec.SchemaProps{
							Description: "Paused will pause the cron job.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"successfulJobsHistoryLimit": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of successful finished jobs to retain. This is a pointer to distinguish between explicit zero and not specified.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"failedJobsHistoryLimit": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of failed finished jobs to retain. This is a pointer to distinguish between explicit zero and not specified.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"template": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the job that will be created when executing a CronJob.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.CronJobTemplate"),
						},
					},
				},
				Required: []string{"schedule", "template"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.CronJobTemplate"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_AdvancedCronJobStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AdvancedCronJobStatus defines the observed state of AdvancedCronJob",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"active": {
						SchemaProps: spec.SchemaProps{
							Description: "A list of pointers to currently running jobs.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.ObjectReference"),
									},
								},
							},
						},
					},
					"lastScheduleTime": {
						SchemaProps: spec.SchemaProps{
							Description: "Information when was the last time the job was successfully scheduled.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.ObjectReference", "k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_AdvancedStatefulSetTemplateSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AdvancedStatefulSetTemplateSpec defines the subset template of AdvancedStatefulSet.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1beta1.StatefulSetSpec"),
						},
					},
				},
				Required: []string{"spec"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1beta1.StatefulSetSpec", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_BroadcastJob(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "BroadcastJob is the Schema for the broadcastjobs API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.BroadcastJobSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.BroadcastJobStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.BroadcastJobSpec", "github.com/openkruise/kruise-api/apps/v1alpha1.BroadcastJobStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_BroadcastJobList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "BroadcastJobList contains a list of BroadcastJob",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.BroadcastJob"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.BroadcastJob", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_BroadcastJobSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "BroadcastJobSpec defines the desired state of BroadcastJob",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"parallelism": {
						SchemaProps: spec.SchemaProps{
							Description: "Parallelism specifies the maximum desired number of pods the job should run at any given time. The actual number of pods running in steady state will be less than this number when the work left to do is less than max parallelism. Not setting this value means no limit.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"template": {
						SchemaProps: spec.SchemaProps{
							Description: "Template describes the pod that will be created when executing a job.",
							Default:     map[string]interface{}{},
							Ref:         ref("k8s.io/api/core/v1.PodTemplateSpec"),
						},
					},
					"completionPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "CompletionPolicy indicates the completion policy of the job. Default is Always CompletionPolicyType.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.CompletionPolicy"),
						},
					},
					"paused": {
						SchemaProps: spec.SchemaProps{
							Description: "Paused will pause the job.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"failurePolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "FailurePolicy indicates the behavior of the job, when failed pod is found.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.FailurePolicy"),
						},
					},
				},
				Required: []string{"template"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.CompletionPolicy", "github.com/openkruise/kruise-api/apps/v1alpha1.FailurePolicy", "k8s.io/api/core/v1.PodTemplateSpec", "k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_BroadcastJobStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "BroadcastJobStatus defines the observed state of BroadcastJob",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "type",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "The latest available observations of an object's current state.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.JobCondition"),
									},
								},
							},
						},
					},
					"startTime": {
						SchemaProps: spec.SchemaProps{
							Description: "Represents time when the job was acknowledged by the job controller. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"completionTime": {
						SchemaProps: spec.SchemaProps{
							Description: "Represents time when the job was completed. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"active": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of actively running pods.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"succeeded": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of pods which reached phase Succeeded.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"failed": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of pods which reached phase Failed.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"desired": {
						SchemaProps: spec.SchemaProps{
							Description: "The desired number of pods, this is typically equal to the number of nodes satisfied to run pods.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"phase": {
						SchemaProps: spec.SchemaProps{
							Description: "The phase of the job.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.JobCondition", "k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_BroadcastJobTemplateSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "JobTemplateSpec describes the data a Job should have when created from a template",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Standard object's metadata of the jobs created from this template.",
							Default:     map[string]interface{}{},
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Description: "Specification of the desired behavior of the broadcastjob.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.BroadcastJobSpec"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.BroadcastJobSpec", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_CloneSet(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CloneSet is the Schema for the clonesets API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.CloneSetSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.CloneSetStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.CloneSetSpec", "github.com/openkruise/kruise-api/apps/v1alpha1.CloneSetStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_CloneSetCondition(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CloneSetCondition describes the state of a CloneSet at a certain point.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type of CloneSet condition.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Description: "Status of the condition, one of True, False, Unknown.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"lastTransitionTime": {
						SchemaProps: spec.SchemaProps{
							Description: "Last time the condition transitioned from one status to another.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"reason": {
						SchemaProps: spec.SchemaProps{
							Description: "The reason for the condition's last transition.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"message": {
						SchemaProps: spec.SchemaProps{
							Description: "A human readable message indicating details about the transition.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"type", "status"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_CloneSetList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CloneSetList contains a list of CloneSet",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.CloneSet"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.CloneSet", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_CloneSetScaleStrategy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CloneSetScaleStrategy defines strategies for pods scale.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"podsToDelete": {
						SchemaProps: spec.SchemaProps{
							Description: "PodsToDelete is the names of Pod should be deleted. Note that this list will be truncated for non-existing pod names.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"maxUnavailable": {
						SchemaProps: spec.SchemaProps{
							Description: "The maximum number of pods that can be unavailable for scaled pods. This field can control the changes rate of replicas for CloneSet so as to minimize the impact for users' service. The scale will fail if the number of unavailable pods were greater than this MaxUnavailable at scaling up. MaxUnavailable works only when scaling up.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"disablePVCReuse": {
						SchemaProps: spec.SchemaProps{
							Description: "Indicate if cloneSet will reuse already existed pvc to rebuild a new pod",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_CloneSetSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CloneSetSpec defines the desired state of CloneSet",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"replicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Replicas is the desired number of replicas of the given Template. These are replicas in the sense that they are instantiations of the same Template. If unspecified, defaults to 1.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"selector": {
						SchemaProps: spec.SchemaProps{
							Description: "Selector is a label query over pods that should match the replica count. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"),
						},
					},
					"template": {
						SchemaProps: spec.SchemaProps{
							Description: "Template describes the pods that will be created.",
							Default:     map[string]interface{}{},
							Ref:         ref("k8s.io/api/core/v1.PodTemplateSpec"),
						},
					},
					"volumeClaimTemplates": {
						SchemaProps: spec.SchemaProps{
							Description: "VolumeClaimTemplates is a list of claims that pods are allowed to reference. Note that PVC will be deleted when its pod has been deleted.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.PersistentVolumeClaim"),
									},
								},
							},
						},
					},
					"scaleStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "ScaleStrategy indicates the ScaleStrategy that will be employed to create and delete Pods in the CloneSet.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.CloneSetScaleStrategy"),
						},
					},
					"updateStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "UpdateStrategy indicates the UpdateStrategy that will be employed to update Pods in the CloneSet when a revision is made to Template.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.CloneSetUpdateStrategy"),
						},
					},
					"revisionHistoryLimit": {
						SchemaProps: spec.SchemaProps{
							Description: "RevisionHistoryLimit is the maximum number of revisions that will be maintained in the CloneSet's revision history. The revision history consists of all revisions not represented by a currently applied CloneSetSpec version. The default value is 10.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"minReadySeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"lifecycle": {
						SchemaProps: spec.SchemaProps{
							Description: "Lifecycle defines the lifecycle hooks for Pods pre-available(pre-normal), pre-delete, in-place update.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/pub.Lifecycle"),
						},
					},
				},
				Required: []string{"selector", "template"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/pub.Lifecycle", "github.com/openkruise/kruise-api/apps/v1alpha1.CloneSetScaleStrategy", "github.com/openkruise/kruise-api/apps/v1alpha1.CloneSetUpdateStrategy", "k8s.io/api/core/v1.PersistentVolumeClaim", "k8s.io/api/core/v1.PodTemplateSpec", "k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_CloneSetStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CloneSetStatus defines the observed state of CloneSet",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "ObservedGeneration is the most recent generation observed for this CloneSet. It corresponds to the CloneSet's generation, which is updated on mutation by the API Server.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"replicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Replicas is the number of Pods created by the CloneSet controller.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"readyReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "ReadyReplicas is the number of Pods created by the CloneSet controller that have a Ready Condition.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"availableReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "AvailableReplicas is the number of Pods created by the CloneSet controller that have a Ready Condition for at least minReadySeconds.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"updatedReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "UpdatedReplicas is the number of Pods created by the CloneSet controller from the CloneSet version indicated by updateRevision.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"updatedReadyReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "UpdatedReadyReplicas is the number of Pods created by the CloneSet controller from the CloneSet version indicated by updateRevision and have a Ready Condition.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"updatedAvailableReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "UpdatedAvailableReplicas is the number of Pods created by the CloneSet controller from the CloneSet version indicated by updateRevision and have a Ready Condition for at least minReadySeconds. Notice: when enable InPlaceWorkloadVerticalScaling, pod during resource resizing will also be unavailable. This means these pod will be counted in maxUnavailable.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"expectedUpdatedReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "ExpectedUpdatedReplicas is the number of Pods that should be updated by CloneSet controller. This field is calculated via Replicas - Partition.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"updateRevision": {
						SchemaProps: spec.SchemaProps{
							Description: "UpdateRevision, if not empty, indicates the latest revision of the CloneSet.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"currentRevision": {
						SchemaProps: spec.SchemaProps{
							Description: "currentRevision, if not empty, indicates the current revision version of the CloneSet.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"collisionCount": {
						SchemaProps: spec.SchemaProps{
							Description: "CollisionCount is the count of hash collisions for the CloneSet. The CloneSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"conditions": {
						SchemaProps: spec.SchemaProps{
							Description: "Conditions represents the latest available observations of a CloneSet's current state.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.CloneSetCondition"),
									},
								},
							},
						},
					},
					"labelSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "LabelSelector is label selectors for query over pods that should match the replica count used by HPA.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"replicas", "readyReplicas", "availableReplicas", "updatedReplicas", "updatedReadyReplicas"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.CloneSetCondition"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_CloneSetTemplateSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CloneSetTemplateSpec defines the subset template of CloneSet.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.CloneSetSpec"),
						},
					},
				},
				Required: []string{"spec"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.CloneSetSpec", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_CloneSetUpdateStrategy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CloneSetUpdateStrategy defines strategies for pods update.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type indicates the type of the CloneSetUpdateStrategy. Default is ReCreate.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"partition": {
						SchemaProps: spec.SchemaProps{
							Description: "Partition is the desired number of pods in old revisions. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up by default. It means when partition is set during pods updating, (replicas - partition value) number of pods will be updated. Default value is 0.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"maxUnavailable": {
						SchemaProps: spec.SchemaProps{
							Description: "The maximum number of pods that can be unavailable during update or scale. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up by default. When maxSurge > 0, absolute number is calculated from percentage by rounding down. Defaults to 20%.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"maxSurge": {
						SchemaProps: spec.SchemaProps{
							Description: "The maximum number of pods that can be scheduled above the desired replicas during update or specified delete. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. Defaults to 0.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"paused": {
						SchemaProps: spec.SchemaProps{
							Description: "Paused indicates that the CloneSet is paused. Default value is false",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"priorityStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "Priorities are the rules for calculating the priority of updating pods. Each pod to be updated, will pass through these terms and get a sum of weights.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/pub.UpdatePriorityStrategy"),
						},
					},
					"scatterStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "ScatterStrategy defines the scatter rules to make pods been scattered when update. This will avoid pods with the same key-value to be updated in one batch. - Note that pods will be scattered after priority sort. So, although priority strategy and scatter strategy can be applied together, we suggest to use either one of them. - If scatterStrategy is used, we suggest to just use one term. Otherwise, the update order can be hard to understand.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.UpdateScatterTerm"),
									},
								},
							},
						},
					},
					"inPlaceUpdateStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "InPlaceUpdateStrategy contains strategies for in-place update.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/pub.InPlaceUpdateStrategy"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/pub.InPlaceUpdateStrategy", "github.com/openkruise/kruise-api/apps/pub.UpdatePriorityStrategy", "github.com/openkruise/kruise-api/apps/v1alpha1.UpdateScatterTerm", "k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_CompletionPolicy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CompletionPolicy indicates the completion policy for the job",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type indicates the type of the CompletionPolicy. Default is Always.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"activeDeadlineSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "ActiveDeadlineSeconds specifies the duration in seconds relative to the startTime that the job may be active before the system tries to terminate it; value must be positive integer. Only works for Always type.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"ttlSecondsAfterFinished": {
						SchemaProps: spec.SchemaProps{
							Description: "ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, ttlSecondsAfterFinished after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is unset, the Job won't be automatically deleted. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Only works for Always type",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ContainerProbe(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name is podProbeMarker.Name#probe.Name",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"containerName": {
						SchemaProps: spec.SchemaProps{
							Description: "container name",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"probe": {
						SchemaProps: spec.SchemaProps{
							Description: "container probe spec",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.ContainerProbeSpec"),
						},
					},
				},
				Required: []string{"name", "containerName", "probe"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.ContainerProbeSpec"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ContainerProbeSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"exec": {
						SchemaProps: spec.SchemaProps{
							Description: "Exec specifies the action to take.",
							Ref:         ref("k8s.io/api/core/v1.ExecAction"),
						},
					},
					"httpGet": {
						SchemaProps: spec.SchemaProps{
							Description: "HTTPGet specifies the http request to perform.",
							Ref:         ref("k8s.io/api/core/v1.HTTPGetAction"),
						},
					},
					"tcpSocket": {
						SchemaProps: spec.SchemaProps{
							Description: "TCPSocket specifies an action involving a TCP port.",
							Ref:         ref("k8s.io/api/core/v1.TCPSocketAction"),
						},
					},
					"grpc": {
						SchemaProps: spec.SchemaProps{
							Description: "GRPC specifies an action involving a GRPC port.",
							Ref:         ref("k8s.io/api/core/v1.GRPCAction"),
						},
					},
					"initialDelaySeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"timeoutSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"periodSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"successThreshold": {
						SchemaProps: spec.SchemaProps{
							Description: "Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"failureThreshold": {
						SchemaProps: spec.SchemaProps{
							Description: "Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"terminationGracePeriodSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.ExecAction", "k8s.io/api/core/v1.GRPCAction", "k8s.io/api/core/v1.HTTPGetAction", "k8s.io/api/core/v1.TCPSocketAction"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ContainerProbeState(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name is podProbeMarker.Name#probe.Name",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"state": {
						SchemaProps: spec.SchemaProps{
							Description: "container probe exec state, True or False",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"lastProbeTime": {
						SchemaProps: spec.SchemaProps{
							Description: "Last time we probed the condition.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"lastTransitionTime": {
						SchemaProps: spec.SchemaProps{
							Description: "Last time the condition transitioned from one status to another.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"message": {
						SchemaProps: spec.SchemaProps{
							Description: "If Status=True, Message records the return result of Probe. If Status=False, Message records Probe's error message",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"name", "state"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ContainerRecreateRequest(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ContainerRecreateRequest is the Schema for the containerrecreaterequests API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.ContainerRecreateRequestSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.ContainerRecreateRequestStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.ContainerRecreateRequestSpec", "github.com/openkruise/kruise-api/apps/v1alpha1.ContainerRecreateRequestStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ContainerRecreateRequestContainer(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ContainerRecreateRequestContainer defines the container that need to recreate.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the container that need to recreate. It must be existing in the real pod.Spec.Containers.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"preStop": {
						SchemaProps: spec.SchemaProps{
							Description: "PreStop is synced from the real container in Pod spec during this ContainerRecreateRequest creating. Populated by the system. Read-only.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.ProbeHandler"),
						},
					},
					"ports": {
						SchemaProps: spec.SchemaProps{
							Description: "Ports is synced from the real container in Pod spec during this ContainerRecreateRequest creating. Populated by the system. Read-only.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.ContainerPort"),
									},
								},
							},
						},
					},
					"statusContext": {
						SchemaProps: spec.SchemaProps{
							Description: "StatusContext is synced from the real Pod status during this ContainerRecreateRequest creating. Populated by the system. Read-only.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.ContainerRecreateRequestContainerContext"),
						},
					},
				},
				Required: []string{"name"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.ContainerRecreateRequestContainerContext", "github.com/openkruise/kruise-api/apps/v1alpha1.ProbeHandler", "k8s.io/api/core/v1.ContainerPort"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ContainerRecreateRequestContainerContext(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ContainerRecreateRequestContainerContext contains context status of the container that need to recreate.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"containerID": {
						SchemaProps: spec.SchemaProps{
							Description: "Container's ID in the format 'docker://<container_id>'.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"restartCount": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of times the container has been restarted, currently based on the number of dead containers that have not yet been removed. Note that this is calculated from dead containers. But those containers are subject to garbage collection. This value will get capped at 5 by GC.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
				Required: []string{"containerID", "restartCount"},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ContainerRecreateRequestContainerRecreateState(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ContainerRecreateRequestContainerRecreateState contains the recreation state of the container.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the container.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"phase": {
						SchemaProps: spec.SchemaProps{
							Description: "Phase indicates the recreation phase of the container.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"message": {
						SchemaProps: spec.SchemaProps{
							Description: "A human readable message indicating details about this state.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"isKilled": {
						SchemaProps: spec.SchemaProps{
							Description: "Containers are killed by kruise daemon",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
				Required: []string{"name", "phase"},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ContainerRecreateRequestList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ContainerRecreateRequestList contains a list of ContainerRecreateRequest",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.ContainerRecreateRequest"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.ContainerRecreateRequest", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ContainerRecreateRequestSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ContainerRecreateRequestSpec defines the desired state of ContainerRecreateRequest",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"podName": {
						SchemaProps: spec.SchemaProps{
							Description: "PodName is name of the Pod that owns the recreated containers.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"containers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Containers contains the containers that need to recreate in the Pod.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.ContainerRecreateRequestContainer"),
									},
								},
							},
						},
					},
					"strategy": {
						SchemaProps: spec.SchemaProps{
							Description: "Strategy defines strategies for containers recreation.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.ContainerRecreateRequestStrategy"),
						},
					},
					"activeDeadlineSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "ActiveDeadlineSeconds is the deadline duration of this ContainerRecreateRequest.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"ttlSecondsAfterFinished": {
						SchemaProps: spec.SchemaProps{
							Description: "TTLSecondsAfterFinished is the TTL duration after this ContainerRecreateRequest has completed.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
				Required: []string{"podName", "containers"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.ContainerRecreateRequestContainer", "github.com/openkruise/kruise-api/apps/v1alpha1.ContainerRecreateRequestStrategy"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ContainerRecreateRequestStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ContainerRecreateRequestStatus defines the observed state of ContainerRecreateRequest",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"phase": {
						SchemaProps: spec.SchemaProps{
							Description: "Phase of this ContainerRecreateRequest, e.g. Pending, Recreating, Completed",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"completionTime": {
						SchemaProps: spec.SchemaProps{
							Description: "Represents time when the ContainerRecreateRequest was completed. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"message": {
						SchemaProps: spec.SchemaProps{
							Description: "A human readable message indicating details about this ContainerRecreateRequest.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"containerRecreateStates": {
						SchemaProps: spec.SchemaProps{
							Description: "ContainerRecreateStates contains the recreation states of the containers.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.ContainerRecreateRequestContainerRecreateState"),
									},
								},
							},
						},
					},
				},
				Required: []string{"phase"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.ContainerRecreateRequestContainerRecreateState", "k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ContainerRecreateRequestStrategy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ContainerRecreateRequestStrategy contains the strategies for containers recreation.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"failurePolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "FailurePolicy decides whether to continue if one container fails to recreate",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"orderedRecreate": {
						SchemaProps: spec.SchemaProps{
							Description: "OrderedRecreate indicates whether to recreate the next container only if the previous one has recreated completely.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"forceRecreate": {
						SchemaProps: spec.SchemaProps{
							Description: "ForceRecreate indicates whether to force kill the container even if the previous container is starting.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"terminationGracePeriodSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "TerminationGracePeriodSeconds is the optional duration in seconds to wait the container terminating gracefully. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, we will use pod.Spec.TerminationGracePeriodSeconds as default value.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"unreadyGracePeriodSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "UnreadyGracePeriodSeconds is the optional duration in seconds to mark Pod as not ready over this duration before executing preStop hook and stopping the container.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"minStartedSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Minimum number of seconds for which a newly created container should be started and ready without any of its container crashing, for it to be considered Succeeded. Defaults to 0 (container will be considered Succeeded as soon as it is started and ready)",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ContainerRecreateRequestSyncContainerStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ContainerRecreateRequestSyncContainerStatus only uses in the annotation `crr.apps.kruise.io/sync-container-statuses`.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"ready": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies whether the container has passed its readiness probe.",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"restartCount": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of times the container has been restarted, currently based on the number of dead containers that have not yet been removed.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"containerID": {
						SchemaProps: spec.SchemaProps{
							Description: "Container's ID in the format 'docker://<container_id>'.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"name", "ready", "restartCount"},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_CronJobTemplate(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"jobTemplate": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the job that will be created when executing a CronJob.",
							Ref:         ref("k8s.io/api/batch/v1.JobTemplateSpec"),
						},
					},
					"broadcastJobTemplate": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the broadcastjob that will be created when executing a BroadcastCronJob.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.BroadcastJobTemplateSpec"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.BroadcastJobTemplateSpec", "k8s.io/api/batch/v1.JobTemplateSpec"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_DaemonSet(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "DaemonSet is the Schema for the daemonsets API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.DaemonSetSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.DaemonSetStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.DaemonSetSpec", "github.com/openkruise/kruise-api/apps/v1alpha1.DaemonSetStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_DaemonSetList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "DaemonSetList contains a list of DaemonSet",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.DaemonSet"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.DaemonSet", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_DaemonSetSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "DaemonSetSpec defines the desired state of DaemonSet",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"selector": {
						SchemaProps: spec.SchemaProps{
							Description: "A label query over pods that are managed by the daemon set. Must match in order to be controlled. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"),
						},
					},
					"template": {
						SchemaProps: spec.SchemaProps{
							Description: "An object that describes the pod that will be created. The DaemonSet will create exactly one copy of this pod on every node that matches the template's node selector (or on every node if no node selector is specified). More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template",
							Default:     map[string]interface{}{},
							Ref:         ref("k8s.io/api/core/v1.PodTemplateSpec"),
						},
					},
					"updateStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "An update strategy to replace existing DaemonSet pods with new pods.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.DaemonSetUpdateStrategy"),
						},
					},
					"minReadySeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "The minimum number of seconds for which a newly created DaemonSet pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready).",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"burstReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "BurstReplicas is a rate limiter for booting pods on a lot of pods. The default value is 250",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"revisionHistoryLimit": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of old history to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"lifecycle": {
						SchemaProps: spec.SchemaProps{
							Description: "Lifecycle defines the lifecycle hooks for Pods pre-delete, in-place update. Currently, we only support pre-delete hook for Advanced DaemonSet.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/pub.Lifecycle"),
						},
					},
				},
				Required: []string{"selector", "template"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/pub.Lifecycle", "github.com/openkruise/kruise-api/apps/v1alpha1.DaemonSetUpdateStrategy", "k8s.io/api/core/v1.PodTemplateSpec", "k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector", "k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_DaemonSetStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "DaemonSetStatus defines the observed state of DaemonSet",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"currentNumberScheduled": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of nodes that are running at least 1 daemon pod and are supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"numberMisscheduled": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of nodes that are running the daemon pod, but are not supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"desiredNumberScheduled": {
						SchemaProps: spec.SchemaProps{
							Description: "The total number of nodes that should be running the daemon pod (including nodes correctly running the daemon pod). More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"numberReady": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and ready.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "The most recent generation observed by the daemon set controller.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"updatedNumberScheduled": {
						SchemaProps: spec.SchemaProps{
							Description: "The total number of nodes that are running updated daemon pod",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"numberAvailable": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and available (ready for at least spec.minReadySeconds)",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"numberUnavailable": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of nodes that should be running the daemon pod and have none of the daemon pod running and available (ready for at least spec.minReadySeconds)",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"collisionCount": {
						SchemaProps: spec.SchemaProps{
							Description: "Count of hash collisions for the DaemonSet. The DaemonSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "type",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Represents the latest available observations of a DaemonSet's current state.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/apps/v1.DaemonSetCondition"),
									},
								},
							},
						},
					},
					"daemonSetHash": {
						SchemaProps: spec.SchemaProps{
							Description: "DaemonSetHash is the controller-revision-hash, which represents the latest version of the DaemonSet.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"currentNumberScheduled", "numberMisscheduled", "desiredNumberScheduled", "numberReady", "updatedNumberScheduled", "daemonSetHash"},
			},
		},
		Dependencies: []string{
			"k8s.io/api/apps/v1.DaemonSetCondition"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_DaemonSetUpdateStrategy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type of daemon set update. Can be \"RollingUpdate\" or \"OnDelete\". Default is RollingUpdate.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"rollingUpdate": {
						SchemaProps: spec.SchemaProps{
							Description: "Rolling update config params. Present only if type = \"RollingUpdate\".",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.RollingUpdateDaemonSet"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.RollingUpdateDaemonSet"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_DeploymentTemplateSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "DeploymentTemplateSpec defines the subset template of Deployment.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/api/apps/v1.DeploymentSpec"),
						},
					},
				},
				Required: []string{"spec"},
			},
		},
		Dependencies: []string{
			"k8s.io/api/apps/v1.DeploymentSpec", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_EphemeralContainerTemplateSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "EphemeralContainerTemplateSpec describes template spec of ephemeral containers",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"ephemeralContainers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "EphemeralContainers defines ephemeral container list in match pods.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.EphemeralContainer"),
									},
								},
							},
						},
					},
				},
				Required: []string{"ephemeralContainers"},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.EphemeralContainer"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_EphemeralJob(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "EphemeralJob is the Schema for the ephemeraljobs API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.EphemeralJobSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.EphemeralJobStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.EphemeralJobSpec", "github.com/openkruise/kruise-api/apps/v1alpha1.EphemeralJobStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_EphemeralJobCondition(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "JobCondition describes current state of a job.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type of job condition, Complete or Failed.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Description: "Status of the condition, one of True, False, Unknown.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"lastProbeTime": {
						SchemaProps: spec.SchemaProps{
							Description: "Last time the condition was checked.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"lastTransitionTime": {
						SchemaProps: spec.SchemaProps{
							Description: "Last time the condition transit from one status to another.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"reason": {
						SchemaProps: spec.SchemaProps{
							Description: "(brief) reason for the condition's last transition.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"message": {
						SchemaProps: spec.SchemaProps{
							Description: "Human readable message indicating details about last transition.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"type", "status"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_EphemeralJobList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "EphemeralJobList contains a list of EphemeralJob",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.EphemeralJob"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.EphemeralJob", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_EphemeralJobSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "EphemeralJobSpec defines the desired state of EphemeralJob",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"selector": {
						SchemaProps: spec.SchemaProps{
							Description: "INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run \"make\" to regenerate code after modifying this file Selector is a label query over pods that should match the pod labels.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"),
						},
					},
					"replicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Replicas indicates a part of the quantity from matched pods by selector. Usually it is used for gray scale working. if Replicas exceeded the matched number by selector or not be set, replicas will not work.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"parallelism": {
						SchemaProps: spec.SchemaProps{
							Description: "Parallelism specifies the maximum desired number of pods which matches running ephemeral containers.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"template": {
						SchemaProps: spec.SchemaProps{
							Description: "Template describes the ephemeral container that will be created.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.EphemeralContainerTemplateSpec"),
						},
					},
					"paused": {
						SchemaProps: spec.SchemaProps{
							Description: "Paused will pause the ephemeral job.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"activeDeadlineSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "ActiveDeadlineSeconds specifies the duration in seconds relative to the startTime that the job may be active before the system tries to terminate it; value must be positive integer. Only works for Always type.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"ttlSecondsAfterFinished": {
						SchemaProps: spec.SchemaProps{
							Description: "ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, ttlSecondsAfterFinished after the eJob finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is unset, default value is 1800 If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
				Required: []string{"selector", "template"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.EphemeralContainerTemplateSpec", "k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_EphemeralJobStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "EphemeralJobStatus defines the observed state of EphemeralJob",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "type",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run \"make\" to regenerate code after modifying this file",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.EphemeralJobCondition"),
									},
								},
							},
						},
					},
					"startTime": {
						SchemaProps: spec.SchemaProps{
							Description: "Represents time when the job was acknowledged by the job controller. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"completionTime": {
						SchemaProps: spec.SchemaProps{
							Description: "Represents time when the job was completed. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"phase": {
						SchemaProps: spec.SchemaProps{
							Description: "The phase of the job.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"match": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of total matched pods.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"running": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of actively running pods.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"succeeded": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of pods which reached phase Succeeded.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"waiting": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of waiting pods.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"failed": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of pods which reached phase Failed.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.EphemeralJobCondition", "k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_FailedImageStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "FailedImageStatus the state of ImagePullJob which has the failed nodes(status.Failed>0)",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"imagePullJob": {
						SchemaProps: spec.SchemaProps{
							Description: "The name of ImagePullJob which has the failed nodes(status.Failed>0)",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the image",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"message": {
						SchemaProps: spec.SchemaProps{
							Description: "The text prompt for job running status.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_FailurePolicy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "FailurePolicy indicates the behavior of the job, when failed pod is found.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type indicates the type of FailurePolicyType. Default is FailurePolicyTypeFailFast.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"restartLimit": {
						SchemaProps: spec.SchemaProps{
							Description: "RestartLimit specifies the number of retries before marking the pod failed.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ImageListPullJob(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ImageListPullJob is the Schema for the imagelistpulljobs API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.ImageListPullJobSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.ImageListPullJobStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.ImageListPullJobSpec", "github.com/openkruise/kruise-api/apps/v1alpha1.ImageListPullJobStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ImageListPullJobList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ImageListPullJobList contains a list of ImageListPullJob",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.ImageListPullJob"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.ImageListPullJob", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ImageListPullJobSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ImageListPullJobSpec defines the desired state of ImageListPullJob",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"images": {
						SchemaProps: spec.SchemaProps{
							Description: "Images is the image list to be pulled by the job",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"pullSecrets": {
						SchemaProps: spec.SchemaProps{
							Description: "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling the image. If specified, these secrets will be passed to individual puller implementations for them to use.  For example, in the case of docker, only DockerConfig type secrets are honored.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"selector": {
						SchemaProps: spec.SchemaProps{
							Description: "Selector is a query over nodes that should match the job. nil to match all nodes.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.ImagePullJobNodeSelector"),
						},
					},
					"podSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "PodSelector is a query over pods that should pull image on nodes of these pods. Mutually exclusive with Selector.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.ImagePullJobPodSelector"),
						},
					},
					"parallelism": {
						SchemaProps: spec.SchemaProps{
							Description: "Parallelism is the requested parallelism, it can be set to any non-negative value. If it is unspecified, it defaults to 1. If it is specified as 0, then the Job is effectively paused until it is increased.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"pullPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "PullPolicy is an optional field to set parameters of the pulling task. If not specified, the system will use the default values.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.PullPolicy"),
						},
					},
					"completionPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "CompletionPolicy indicates the completion policy of the job. Default is Always CompletionPolicyType.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.CompletionPolicy"),
						},
					},
					"sandboxConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "SandboxConfig support attach metadata in PullImage CRI interface during ImagePulljobs",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.SandboxConfig"),
						},
					},
					"imagePullPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Image pull policy. One of Always, IfNotPresent. Defaults to IfNotPresent.\n\nPossible enum values:\n - `\"Always\"` means that kruise-daemon always attempts to pull the latest image.\n - `\"IfNotPresent\"` means that kruise-daemon pulls if the image isn't present on disk.",
							Type:        []string{"string"},
							Format:      "",
							Enum:        []interface{}{"Always", "IfNotPresent"},
						},
					},
				},
				Required: []string{"images", "completionPolicy"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.CompletionPolicy", "github.com/openkruise/kruise-api/apps/v1alpha1.ImagePullJobNodeSelector", "github.com/openkruise/kruise-api/apps/v1alpha1.ImagePullJobPodSelector", "github.com/openkruise/kruise-api/apps/v1alpha1.PullPolicy", "github.com/openkruise/kruise-api/apps/v1alpha1.SandboxConfig", "k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ImageListPullJobStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ImageListPullJobStatus defines the observed state of ImageListPullJob",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"startTime": {
						SchemaProps: spec.SchemaProps{
							Description: "Represents time when the job was acknowledged by the job controller. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"completionTime": {
						SchemaProps: spec.SchemaProps{
							Description: "Represents time when the all the image pull job was completed. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"desired": {
						SchemaProps: spec.SchemaProps{
							Description: "The desired number of ImagePullJobs, this is typically equal to the number of len(spec.Images).",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"active": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of running ImagePullJobs which are acknowledged by the imagepulljob controller.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"completed": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of ImagePullJobs which are finished",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"succeeded": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of image pull job which are finished and status.Succeeded==status.Desired.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"failedImageStatuses": {
						SchemaProps: spec.SchemaProps{
							Description: "The status of ImagePullJob which has the failed nodes(status.Failed>0) .",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("github.com/openkruise/kruise-api/apps/v1alpha1.FailedImageStatus"),
									},
								},
							},
						},
					},
				},
				Required: []string{"desired"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.FailedImageStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ImagePullJob(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ImagePullJob is the Schema for the imagepulljobs API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.ImagePullJobSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.ImagePullJobStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.ImagePullJobSpec", "github.com/openkruise/kruise-api/apps/v1alpha1.ImagePullJobStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ImagePullJobList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ImagePullJobList contains a list of ImagePullJob",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.ImagePullJob"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.ImagePullJob", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ImagePullJobNodeSelector(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ImagePullJobNodeSelector is a selector over nodes",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"names": {
						SchemaProps: spec.SchemaProps{
							Description: "Names specify a set of nodes to execute the job.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"matchLabels": {
						SchemaProps: spec.SchemaProps{
							Description: "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"matchExpressions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelectorRequirement"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelectorRequirement"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ImagePullJobPodSelector(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ImagePullJobPodSelector is a selector over pods",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"matchLabels": {
						SchemaProps: spec.SchemaProps{
							Description: "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"matchExpressions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelectorRequirement"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelectorRequirement"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ImagePullJobSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ImagePullJobSpec defines the desired state of ImagePullJob",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"image": {
						SchemaProps: spec.SchemaProps{
							Description: "Image is the image to be pulled by the job",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"pullSecrets": {
						SchemaProps: spec.SchemaProps{
							Description: "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling the image. If specified, these secrets will be passed to individual puller implementations for them to use.  For example, in the case of docker, only DockerConfig type secrets are honored.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"selector": {
						SchemaProps: spec.SchemaProps{
							Description: "Selector is a query over nodes that should match the job. nil to match all nodes.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.ImagePullJobNodeSelector"),
						},
					},
					"podSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "PodSelector is a query over pods that should pull image on nodes of these pods. Mutually exclusive with Selector.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.ImagePullJobPodSelector"),
						},
					},
					"parallelism": {
						SchemaProps: spec.SchemaProps{
							Description: "Parallelism is the requested parallelism, it can be set to any non-negative value. If it is unspecified, it defaults to 1. If it is specified as 0, then the Job is effectively paused until it is increased.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"pullPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "PullPolicy is an optional field to set parameters of the pulling task. If not specified, the system will use the default values.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.PullPolicy"),
						},
					},
					"completionPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "CompletionPolicy indicates the completion policy of the job. Default is Always CompletionPolicyType.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.CompletionPolicy"),
						},
					},
					"sandboxConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "SandboxConfig support attach metadata in PullImage CRI interface during ImagePulljobs",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.SandboxConfig"),
						},
					},
					"imagePullPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Image pull policy. One of Always, IfNotPresent. Defaults to IfNotPresent.\n\nPossible enum values:\n - `\"Always\"` means that kruise-daemon always attempts to pull the latest image.\n - `\"IfNotPresent\"` means that kruise-daemon pulls if the image isn't present on disk.",
							Type:        []string{"string"},
							Format:      "",
							Enum:        []interface{}{"Always", "IfNotPresent"},
						},
					},
				},
				Required: []string{"image", "completionPolicy"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.CompletionPolicy", "github.com/openkruise/kruise-api/apps/v1alpha1.ImagePullJobNodeSelector", "github.com/openkruise/kruise-api/apps/v1alpha1.ImagePullJobPodSelector", "github.com/openkruise/kruise-api/apps/v1alpha1.PullPolicy", "github.com/openkruise/kruise-api/apps/v1alpha1.SandboxConfig", "k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ImagePullJobStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ImagePullJobStatus defines the observed state of ImagePullJob",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"startTime": {
						SchemaProps: spec.SchemaProps{
							Description: "Represents time when the job was acknowledged by the job controller. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"completionTime": {
						SchemaProps: spec.SchemaProps{
							Description: "Represents time when the job was completed. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"desired": {
						SchemaProps: spec.SchemaProps{
							Description: "The desired number of pulling tasks, this is typically equal to the number of nodes satisfied.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"active": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of actively running pulling tasks.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"succeeded": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of pulling tasks which reached phase Succeeded.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"failed": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of pulling tasks  which reached phase Failed.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"message": {
						SchemaProps: spec.SchemaProps{
							Description: "The text prompt for job running status.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"failedNodes": {
						SchemaProps: spec.SchemaProps{
							Description: "The nodes that failed to pull the image.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
				Required: []string{"desired"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ImagePullJobTemplate(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"pullSecrets": {
						SchemaProps: spec.SchemaProps{
							Description: "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling the image. If specified, these secrets will be passed to individual puller implementations for them to use.  For example, in the case of docker, only DockerConfig type secrets are honored.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"selector": {
						SchemaProps: spec.SchemaProps{
							Description: "Selector is a query over nodes that should match the job. nil to match all nodes.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.ImagePullJobNodeSelector"),
						},
					},
					"podSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "PodSelector is a query over pods that should pull image on nodes of these pods. Mutually exclusive with Selector.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.ImagePullJobPodSelector"),
						},
					},
					"parallelism": {
						SchemaProps: spec.SchemaProps{
							Description: "Parallelism is the requested parallelism, it can be set to any non-negative value. If it is unspecified, it defaults to 1. If it is specified as 0, then the Job is effectively paused until it is increased.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"pullPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "PullPolicy is an optional field to set parameters of the pulling task. If not specified, the system will use the default values.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.PullPolicy"),
						},
					},
					"completionPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "CompletionPolicy indicates the completion policy of the job. Default is Always CompletionPolicyType.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.CompletionPolicy"),
						},
					},
					"sandboxConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "SandboxConfig support attach metadata in PullImage CRI interface during ImagePulljobs",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.SandboxConfig"),
						},
					},
					"imagePullPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Image pull policy. One of Always, IfNotPresent. Defaults to IfNotPresent.\n\nPossible enum values:\n - `\"Always\"` means that kruise-daemon always attempts to pull the latest image.\n - `\"IfNotPresent\"` means that kruise-daemon pulls if the image isn't present on disk.",
							Type:        []string{"string"},
							Format:      "",
							Enum:        []interface{}{"Always", "IfNotPresent"},
						},
					},
				},
				Required: []string{"completionPolicy"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.CompletionPolicy", "github.com/openkruise/kruise-api/apps/v1alpha1.ImagePullJobNodeSelector", "github.com/openkruise/kruise-api/apps/v1alpha1.ImagePullJobPodSelector", "github.com/openkruise/kruise-api/apps/v1alpha1.PullPolicy", "github.com/openkruise/kruise-api/apps/v1alpha1.SandboxConfig", "k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ImageSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ImageSpec defines the pulling spec of an image",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"pullSecrets": {
						SchemaProps: spec.SchemaProps{
							Description: "PullSecrets is an optional list of references to secrets in the same namespace to use for pulling the image. If specified, these secrets will be passed to individual puller implementations for them to use.  For example, in the case of docker, only DockerConfig type secrets are honored.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.ReferenceObject"),
									},
								},
							},
						},
					},
					"tags": {
						SchemaProps: spec.SchemaProps{
							Description: "Tags is a list of versions of this image",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.ImageTagSpec"),
									},
								},
							},
						},
					},
					"sandboxConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "SandboxConfig support attach metadata in PullImage CRI interface during ImagePulljobs",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.SandboxConfig"),
						},
					},
				},
				Required: []string{"tags"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.ImageTagSpec", "github.com/openkruise/kruise-api/apps/v1alpha1.ReferenceObject", "github.com/openkruise/kruise-api/apps/v1alpha1.SandboxConfig"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ImageStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ImageStatus defines the pulling status of an image",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"tags": {
						SchemaProps: spec.SchemaProps{
							Description: "Represents statuses of pulling tasks on this node",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.ImageTagStatus"),
									},
								},
							},
						},
					},
				},
				Required: []string{"tags"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.ImageTagStatus"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ImageTagPullPolicy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ImageTagPullPolicy defines the policy of the pulling task",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"timeoutSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the timeout of the pulling task. Defaults to 600",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"backoffLimit": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the number of retries before marking the pulling task failed. Defaults to 3",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"ttlSecondsAfterFinished": {
						SchemaProps: spec.SchemaProps{
							Description: "TTLSecondsAfterFinished limits the lifetime of a pulling task that has finished execution (either Complete or Failed). If this field is set, ttlSecondsAfterFinished after the task finishes, it is eligible to be automatically deleted. If this field is unset, the task won't be automatically deleted. If this field is set to zero, the task becomes eligible to be deleted immediately after it finishes.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"activeDeadlineSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "ActiveDeadlineSeconds specifies the duration in seconds relative to the startTime that the task may be active before the system tries to terminate it; value must be positive integer. if not specified, the system will never terminate it.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
				},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ImageTagSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ImageTagSpec defines the pulling spec of an image tag",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"tag": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the image tag",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"createdAt": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the create time of this tag",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"pullPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "PullPolicy is an optional field to set parameters of the pulling task. If not specified, the system will use the default values.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.ImageTagPullPolicy"),
						},
					},
					"ownerReferences": {
						SchemaProps: spec.SchemaProps{
							Description: "List of objects depended by this object. If this image is managed by a controller, then an entry in this list will point to this controller.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.ObjectReference"),
									},
								},
							},
						},
					},
					"version": {
						SchemaProps: spec.SchemaProps{
							Description: "An opaque value that represents the internal version of this tag that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server.\n\nPopulated by the system. Read-only. Value must be treated as opaque by clients and .",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"imagePullPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Image pull policy. One of Always, IfNotPresent. Defaults to IfNotPresent.\n\nPossible enum values:\n - `\"Always\"` means that kruise-daemon always attempts to pull the latest image.\n - `\"IfNotPresent\"` means that kruise-daemon pulls if the image isn't present on disk.",
							Type:        []string{"string"},
							Format:      "",
							Enum:        []interface{}{"Always", "IfNotPresent"},
						},
					},
				},
				Required: []string{"tag"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.ImageTagPullPolicy", "k8s.io/api/core/v1.ObjectReference", "k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ImageTagStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ImageTagStatus defines the pulling status of an image tag",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"tag": {
						SchemaProps: spec.SchemaProps{
							Description: "Represents the image tag.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"phase": {
						SchemaProps: spec.SchemaProps{
							Description: "Represents the image pulling task phase.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"progress": {
						SchemaProps: spec.SchemaProps{
							Description: "Represents the pulling progress of this tag, which is between 0-100. There is no guarantee of monotonic consistency, and it may be a rollback due to retry during pulling.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"startTime": {
						SchemaProps: spec.SchemaProps{
							Description: "Represents time when the pulling task was acknowledged by the image puller. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"completionTime": {
						SchemaProps: spec.SchemaProps{
							Description: "Represents time when the pulling task was completed. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"version": {
						SchemaProps: spec.SchemaProps{
							Description: "Represents the internal version of this tag that the daemon handled.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"imageID": {
						SchemaProps: spec.SchemaProps{
							Description: "Represents the ID of this image.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"message": {
						SchemaProps: spec.SchemaProps{
							Description: "Represents the summary information of this node",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"tag", "phase"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_JobCondition(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "JobCondition describes current state of a job.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type of job condition, Complete or Failed.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Description: "Status of the condition, one of True, False, Unknown.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"lastProbeTime": {
						SchemaProps: spec.SchemaProps{
							Description: "Last time the condition was checked.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"lastTransitionTime": {
						SchemaProps: spec.SchemaProps{
							Description: "Last time the condition transit from one status to another.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"reason": {
						SchemaProps: spec.SchemaProps{
							Description: "(brief) reason for the condition's last transition.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"message": {
						SchemaProps: spec.SchemaProps{
							Description: "Human readable message indicating details about last transition.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"type", "status"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ManualUpdate(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ManualUpdate is a update strategy which allows users to control the update progress by providing the partition of each subset.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"partitions": {
						SchemaProps: spec.SchemaProps{
							Description: "Indicates number of subset partition.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: 0,
										Type:    []string{"integer"},
										Format:  "int32",
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_NodeImage(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "NodeImage is the Schema for the nodeimages API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.NodeImageSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.NodeImageStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.NodeImageSpec", "github.com/openkruise/kruise-api/apps/v1alpha1.NodeImageStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_NodeImageList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "NodeImageList contains a list of NodeImage",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.NodeImage"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.NodeImage", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_NodeImageSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "NodeImageSpec defines the desired state of NodeImage",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"images": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies images to be pulled on this node It can not be more than 256 for each NodeImage",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.ImageSpec"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.ImageSpec"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_NodeImageStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "NodeImageStatus defines the observed state of NodeImage",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"desired": {
						SchemaProps: spec.SchemaProps{
							Description: "The desired number of pulling tasks, this is typically equal to the number of images in spec.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"succeeded": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of pulling tasks which reached phase Succeeded.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"failed": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of pulling tasks  which reached phase Failed.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"pulling": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of pulling tasks which are not finished.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"imageStatuses": {
						SchemaProps: spec.SchemaProps{
							Description: "all statuses of active image pulling tasks",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.ImageStatus"),
									},
								},
							},
						},
					},
					"firstSyncStatus": {
						SchemaProps: spec.SchemaProps{
							Description: "The first of all job has finished on this node. When a node is added to the cluster, we want to know the time when the node's image pulling is completed, and use it to trigger the operation of the upper system.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.SyncStatus"),
						},
					},
				},
				Required: []string{"desired"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.ImageStatus", "github.com/openkruise/kruise-api/apps/v1alpha1.SyncStatus"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_NodePodProbe(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "NodePodProbe is the Schema for the NodePodProbe API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.NodePodProbeSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.NodePodProbeStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.NodePodProbeSpec", "github.com/openkruise/kruise-api/apps/v1alpha1.NodePodProbeStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_NodePodProbeList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "NodePodProbeList contains a list of NodePodProbe",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.NodePodProbe"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.NodePodProbe", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_NodePodProbeSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "NodePodProbeSpec defines the desired state of NodePodProbe",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"podProbes": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.PodProbe"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.PodProbe"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_NodePodProbeStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"podProbeStatuses": {
						SchemaProps: spec.SchemaProps{
							Description: "pod probe results",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.PodProbeStatus"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.PodProbeStatus"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_NodeTopologyTerm(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"nodeTopologyKeys": {
						SchemaProps: spec.SchemaProps{
							Description: "A list of node selector requirements by node's labels.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
				Required: []string{"nodeTopologyKeys"},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_PersistentPodAnnotation(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"key": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
				},
				Required: []string{"key"},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_PersistentPodState(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PersistentPodState is the Schema for the PersistentPodState API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.PersistentPodStateSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.PersistentPodStateStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.PersistentPodStateSpec", "github.com/openkruise/kruise-api/apps/v1alpha1.PersistentPodStateStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_PersistentPodStateList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PersistentPodStateList contains a list of PersistentPodState",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.PersistentPodState"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.PersistentPodState", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_PersistentPodStateSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PersistentPodStateSpec defines the desired state of PersistentPodState",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"targetRef": {
						SchemaProps: spec.SchemaProps{
							Description: "TargetReference contains enough information to let you identify an workload for PersistentPodState Selector and TargetReference are mutually exclusive, TargetReference is priority to take effect current only support StatefulSet",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.TargetReference"),
						},
					},
					"persistentPodAnnotations": {
						SchemaProps: spec.SchemaProps{
							Description: "Persist the annotations information of the pods that need to be saved",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.PersistentPodAnnotation"),
									},
								},
							},
						},
					},
					"requiredPersistentTopology": {
						SchemaProps: spec.SchemaProps{
							Description: "Pod rebuilt topology required for node labels for example kubernetes.io/hostname, failure-domain.beta.kubernetes.io/zone",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.NodeTopologyTerm"),
						},
					},
					"preferredPersistentTopology": {
						SchemaProps: spec.SchemaProps{
							Description: "Pod rebuilt topology preferred for node labels, with xx weight for example  kubernetes.io/hostname, failure-domain.beta.kubernetes.io/zone",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.PreferredTopologyTerm"),
									},
								},
							},
						},
					},
					"persistentPodStateRetentionPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "PersistentPodStateRetentionPolicy describes the policy used for PodState. The default policy of 'WhenScaled' causes when scale down statefulSet, deleting it.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"targetRef"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.NodeTopologyTerm", "github.com/openkruise/kruise-api/apps/v1alpha1.PersistentPodAnnotation", "github.com/openkruise/kruise-api/apps/v1alpha1.PreferredTopologyTerm", "github.com/openkruise/kruise-api/apps/v1alpha1.TargetReference"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_PersistentPodStateStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "observedGeneration is the most recent generation observed for this PersistentPodState. It corresponds to the PersistentPodState's generation, which is updated on mutation by the API Server.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"podStates": {
						SchemaProps: spec.SchemaProps{
							Description: "When the pod is ready, record some status information of the pod, such as: labels, annotations, topologies, etc. map[string]PodState -> map[Pod.Name]PodState",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.PodState"),
									},
								},
							},
						},
					},
				},
				Required: []string{"observedGeneration"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.PodState"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_PodContainerProbe(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "probe name, unique within the Pod(Even between different containers, they cannot be the same)",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"containerName": {
						SchemaProps: spec.SchemaProps{
							Description: "container name",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"probe": {
						SchemaProps: spec.SchemaProps{
							Description: "container probe spec",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.ContainerProbeSpec"),
						},
					},
					"markerPolicy": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "state",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "According to the execution result of ContainerProbe, perform specific actions, such as: patch Pod labels, annotations, ReadinessGate Condition It cannot be null at the same time as PodConditionType.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.ProbeMarkerPolicy"),
									},
								},
							},
						},
					},
					"podConditionType": {
						SchemaProps: spec.SchemaProps{
							Description: "If it is not empty, the Probe execution result will be recorded on the Pod condition. It cannot be null at the same time as MarkerPolicy. For example PodConditionType=game.kruise.io/healthy, pod.status.condition.type = game.kruise.io/healthy. When probe is Succeeded, pod.status.condition.status = True. Otherwise, when the probe fails to execute, pod.status.condition.status = False.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"name", "containerName", "probe"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.ContainerProbeSpec", "github.com/openkruise/kruise-api/apps/v1alpha1.ProbeMarkerPolicy"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_PodProbe(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "pod name",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"namespace": {
						SchemaProps: spec.SchemaProps{
							Description: "pod namespace",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"uid": {
						SchemaProps: spec.SchemaProps{
							Description: "pod uid",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"IP": {
						SchemaProps: spec.SchemaProps{
							Description: "pod ip",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"probes": {
						SchemaProps: spec.SchemaProps{
							Description: "Custom container probe, supports Exec, Tcp, and returns the result to Pod yaml",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.ContainerProbe"),
									},
								},
							},
						},
					},
				},
				Required: []string{"name", "namespace", "uid", "IP"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.ContainerProbe"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_PodProbeMarker(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PodProbeMarker is the Schema for the PodProbeMarker API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.PodProbeMarkerSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.PodProbeMarkerStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.PodProbeMarkerSpec", "github.com/openkruise/kruise-api/apps/v1alpha1.PodProbeMarkerStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_PodProbeMarkerList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PodProbeMarkerList contains a list of PodProbeMarker",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.PodProbeMarker"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.PodProbeMarker", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_PodProbeMarkerSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PodProbeMarkerSpec defines the desired state of PodProbeMarker",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"selector": {
						SchemaProps: spec.SchemaProps{
							Description: "Selector is a label query over pods that should exec custom probe It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"),
						},
					},
					"probes": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Custom container probe, current only support Exec(). Probe Result will record in Pod.Status.Conditions, and condition.type=probe.name. condition.status=True indicates probe success condition.status=False indicates probe fails",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.PodContainerProbe"),
									},
								},
							},
						},
					},
				},
				Required: []string{"selector", "probes"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.PodContainerProbe", "k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_PodProbeMarkerStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "observedGeneration is the most recent generation observed for this PodProbeMarker. It corresponds to the PodProbeMarker's generation, which is updated on mutation by the API Server.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"matchedPods": {
						SchemaProps: spec.SchemaProps{
							Description: "matched Pods",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
				},
				Required: []string{"observedGeneration"},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_PodProbeStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "pod name",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"namespace": {
						SchemaProps: spec.SchemaProps{
							Description: "pod namespace",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"uid": {
						SchemaProps: spec.SchemaProps{
							Description: "pod uid",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"probeStates": {
						SchemaProps: spec.SchemaProps{
							Description: "pod probe result",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.ContainerProbeState"),
									},
								},
							},
						},
					},
				},
				Required: []string{"name", "namespace", "uid"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.ContainerProbeState"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_PodState(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"nodeName": {
						SchemaProps: spec.SchemaProps{
							Description: "pod.spec.nodeName",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"nodeTopologyLabels": {
						SchemaProps: spec.SchemaProps{
							Description: "node topology labels key=value for example kubernetes.io/hostname=node-1",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"annotations": {
						SchemaProps: spec.SchemaProps{
							Description: "pod persistent annotations",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_PreferredTopologyTerm(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"weight": {
						SchemaProps: spec.SchemaProps{
							Default: 0,
							Type:    []string{"integer"},
							Format:  "int32",
						},
					},
					"preference": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.NodeTopologyTerm"),
						},
					},
				},
				Required: []string{"weight", "preference"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.NodeTopologyTerm"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ProbeHandler(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ProbeHandler defines a specific action that should be taken",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"exec": {
						SchemaProps: spec.SchemaProps{
							Description: "One and only one of the following should be specified. Exec specifies the action to take.",
							Ref:         ref("k8s.io/api/core/v1.ExecAction"),
						},
					},
					"httpGet": {
						SchemaProps: spec.SchemaProps{
							Description: "HTTPGet specifies the http request to perform.",
							Ref:         ref("k8s.io/api/core/v1.HTTPGetAction"),
						},
					},
					"tcpSocket": {
						SchemaProps: spec.SchemaProps{
							Description: "TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported",
							Ref:         ref("k8s.io/api/core/v1.TCPSocketAction"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.ExecAction", "k8s.io/api/core/v1.HTTPGetAction", "k8s.io/api/core/v1.TCPSocketAction"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ProbeMarkerPolicy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"state": {
						SchemaProps: spec.SchemaProps{
							Description: "probe status, True or False For example: State=Succeeded, annotations[controller.kubernetes.io/pod-deletion-cost] = '10'. State=Failed, annotations[controller.kubernetes.io/pod-deletion-cost] = '-10'. In addition, if State=Failed is not defined, Exec execution fails, and the annotations[controller.kubernetes.io/pod-deletion-cost] will be Deleted",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"labels": {
						SchemaProps: spec.SchemaProps{
							Description: "Patch Labels pod.labels",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"annotations": {
						SchemaProps: spec.SchemaProps{
							Description: "Patch annotations pod.annotations",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
				Required: []string{"state"},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_PullPolicy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PullPolicy defines the policy of the pulling task",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"timeoutSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the timeout of the pulling task. Defaults to 600",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"backoffLimit": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the number of retries before marking the pulling task failed. Defaults to 3",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ReferenceObject(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ReferenceObject comprises a resource name, with a mandatory namespace, rendered as \"<namespace>/<name>\".",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"namespace": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"name": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ResourceDistribution(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ResourceDistribution is the Schema for the resourcedistributions API.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.ResourceDistributionSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.ResourceDistributionStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.ResourceDistributionSpec", "github.com/openkruise/kruise-api/apps/v1alpha1.ResourceDistributionStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ResourceDistributionCondition(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ResourceDistributionCondition allows a row to be marked with additional information.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type of ResourceDistributionCondition.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Description: "Status of the condition, one of True, False, Unknown.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"lastTransitionTime": {
						SchemaProps: spec.SchemaProps{
							Description: "LastTransitionTime is the last time the condition transitioned from one status to another.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"reason": {
						SchemaProps: spec.SchemaProps{
							Description: "Reason describe human readable message indicating details about last transition.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"failedNamespace": {
						SchemaProps: spec.SchemaProps{
							Description: "FailedNamespaces describe all failed namespaces when Status is False",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
				Required: []string{"type", "status"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ResourceDistributionList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ResourceDistributionList contains a list of ResourceDistribution.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.ResourceDistribution"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.ResourceDistribution", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ResourceDistributionNamespace(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ResourceDistributionNamespace contains a namespace name",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Namespace name",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ResourceDistributionSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ResourceDistributionSpec defines the desired state of ResourceDistribution.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"resource": {
						SchemaProps: spec.SchemaProps{
							Description: "Resource must be the complete yaml that users want to distribute.",
							Ref:         ref("k8s.io/apimachinery/pkg/runtime.RawExtension"),
						},
					},
					"targets": {
						SchemaProps: spec.SchemaProps{
							Description: "Targets defines the namespaces that users want to distribute to.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.ResourceDistributionTargets"),
						},
					},
				},
				Required: []string{"resource", "targets"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.ResourceDistributionTargets", "k8s.io/apimachinery/pkg/runtime.RawExtension"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ResourceDistributionStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ResourceDistributionStatus defines the observed state of ResourceDistribution. ResourceDistributionStatus is recorded by kruise, users' modification is invalid and meaningless.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"desired": {
						SchemaProps: spec.SchemaProps{
							Description: "Desired represents the number of total target namespaces.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"succeeded": {
						SchemaProps: spec.SchemaProps{
							Description: "Succeeded represents the number of successful distributions.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"failed": {
						SchemaProps: spec.SchemaProps{
							Description: "Failed represents the number of failed distributions.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "ObservedGeneration represents the .metadata.generation that the condition was set based upon.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"conditions": {
						SchemaProps: spec.SchemaProps{
							Description: "Conditions describe the condition when Resource creating, updating and deleting.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.ResourceDistributionCondition"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.ResourceDistributionCondition"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ResourceDistributionTargetNamespaces(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"list": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.ResourceDistributionNamespace"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.ResourceDistributionNamespace"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ResourceDistributionTargets(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ResourceDistributionTargets defines the targets of Resource. Four options are provided to select target namespaces.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"allNamespaces": {
						SchemaProps: spec.SchemaProps{
							Description: "If AllNamespaces is true, Resource will be distributed to the all namespaces (except some forbidden namespaces, such as \"kube-system\" and \"kube-public\").",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"excludedNamespaces": {
						SchemaProps: spec.SchemaProps{
							Description: "If ExcludedNamespaces is not empty, Resource will never be distributed to the listed namespaces. ExcludedNamespaces has the highest priority.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.ResourceDistributionTargetNamespaces"),
						},
					},
					"includedNamespaces": {
						SchemaProps: spec.SchemaProps{
							Description: "If IncludedNamespaces is not empty, Resource will be distributed to the listed namespaces.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.ResourceDistributionTargetNamespaces"),
						},
					},
					"namespaceLabelSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "If NamespaceLabelSelector is not empty, Resource will be distributed to the matched namespaces.",
							Default:     map[string]interface{}{},
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.ResourceDistributionTargetNamespaces", "k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_RollingUpdateDaemonSet(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Spec to control the desired behavior of daemon set rolling update.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"rollingUpdateType": {
						SchemaProps: spec.SchemaProps{
							Description: "Type is to specify which kind of rollingUpdate.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"maxUnavailable": {
						SchemaProps: spec.SchemaProps{
							Description: "The maximum number of DaemonSet pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up. This cannot be 0 if MaxSurge is 0 Default value is 1. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their pods stopped for an update at any given time. The update starts by stopping at most 30% of those DaemonSet pods and then brings up new DaemonSet pods in their place. Once the new pods are available, it then proceeds onto other DaemonSet pods, thus ensuring that at least 70% of original number of DaemonSet pods are available at all times during the update.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"maxSurge": {
						SchemaProps: spec.SchemaProps{
							Description: "The maximum number of nodes with an existing available DaemonSet pod that can have an updated DaemonSet pod during during an update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up to a minimum of 1. Default value is 0. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their a new pod created before the old pod is marked as deleted. The update starts by launching new pods on 30% of nodes. Once an updated pod is available (Ready for at least minReadySeconds) the old DaemonSet pod on that node is marked deleted. If the old pod becomes unavailable for any reason (Ready transitions to false, is evicted, or is drained) an updated pod is immediately created on that node without considering surge limits. Allowing surge implies the possibility that the resources consumed by the daemonset on any given node can double if the readiness check fails, and so resource intensive daemonsets should take into account that they may cause evictions during disruption. This is beta field and enabled/disabled by DaemonSetUpdateSurge feature gate.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"selector": {
						SchemaProps: spec.SchemaProps{
							Description: "A label query over nodes that are managed by the daemon set RollingUpdate. Must match in order to be controlled. It must match the node's labels.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"),
						},
					},
					"partition": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of DaemonSet pods remained to be old version. Default value is 0. Maximum value is status.DesiredNumberScheduled, which means no pod will be updated.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"paused": {
						SchemaProps: spec.SchemaProps{
							Description: "Indicates that the daemon set is paused and will not be processed by the daemon set controller.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector", "k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_RollingUpdateStatefulSetStrategy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RollingUpdateStatefulSetStrategy is used to communicate parameter for RollingUpdateStatefulSetStrategyType.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"partition": {
						SchemaProps: spec.SchemaProps{
							Description: "Partition indicates the ordinal at which the StatefulSet should be partitioned by default. But if unorderedUpdate has been set:\n  - Partition indicates the number of pods with non-updated revisions when rolling update.\n  - It means controller will update $(replicas - partition) number of pod.\nDefault value is 0.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"maxUnavailable": {
						SchemaProps: spec.SchemaProps{
							Description: "The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. Also, maxUnavailable can just be allowed to work with Parallel podManagementPolicy. Defaults to 1.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"podUpdatePolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "PodUpdatePolicy indicates how pods should be updated Default value is \"ReCreate\"",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"paused": {
						SchemaProps: spec.SchemaProps{
							Description: "Paused indicates that the StatefulSet is paused. Default value is false",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"unorderedUpdate": {
						SchemaProps: spec.SchemaProps{
							Description: "UnorderedUpdate contains strategies for non-ordered update. If it is not nil, pods will be updated with non-ordered sequence. Noted that UnorderedUpdate can only be allowed to work with Parallel podManagementPolicy",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.UnorderedUpdateStrategy"),
						},
					},
					"inPlaceUpdateStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "InPlaceUpdateStrategy contains strategies for in-place update.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/pub.InPlaceUpdateStrategy"),
						},
					},
					"minReadySeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "MinReadySeconds indicates how long will the pod be considered ready after it's updated. MinReadySeconds works with both OrderedReady and Parallel podManagementPolicy. It affects the pod scale up speed when the podManagementPolicy is set to be OrderedReady. Combined with MaxUnavailable, it affects the pod update speed regardless of podManagementPolicy. Default value is 0, max is 300.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/pub.InPlaceUpdateStrategy", "github.com/openkruise/kruise-api/apps/v1alpha1.UnorderedUpdateStrategy", "k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_SandboxConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SandboxConfig support attach metadata in PullImage CRI interface during ImagePulljobs",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"labels": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"annotations": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_ShareVolumePolicy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_SidecarContainer(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SidecarContainer defines the container of Sidecar",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"image": {
						SchemaProps: spec.SchemaProps{
							Description: "Container image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"command": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Entrypoint array. Not executed within a shell. The container image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"args": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Arguments to the entrypoint. The container image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"workingDir": {
						SchemaProps: spec.SchemaProps{
							Description: "Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"ports": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"containerPort",
									"protocol",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "containerPort",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of ports to expose from the container. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default \"0.0.0.0\" address inside a container will be accessible from the network. Modifying this array with strategic merge patch may corrupt the data. For more information See https://github.com/kubernetes/kubernetes/issues/108255. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.ContainerPort"),
									},
								},
							},
						},
					},
					"envFrom": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.EnvFromSource"),
									},
								},
							},
						},
					},
					"env": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of environment variables to set in the container. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.EnvVar"),
									},
								},
							},
						},
					},
					"resources": {
						SchemaProps: spec.SchemaProps{
							Description: "Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
							Default:     map[string]interface{}{},
							Ref:         ref("k8s.io/api/core/v1.ResourceRequirements"),
						},
					},
					"resizePolicy": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Resources resize policy for the container.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.ContainerResizePolicy"),
									},
								},
							},
						},
					},
					"restartPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "RestartPolicy defines the restart behavior of individual containers in a pod. This field may only be set for init containers, and the only allowed value is \"Always\". For non-init containers or when this field is not specified, the restart behavior is defined by the Pod's restart policy and the container type. Setting the RestartPolicy as \"Always\" for the init container will have the following effect: this init container will be continually restarted on exit until all regular containers have terminated. Once all regular containers have completed, all init containers with restartPolicy \"Always\" will be shut down. This lifecycle differs from normal init containers and is often referred to as a \"sidecar\" container. Although this init container still starts in the init container sequence, it does not wait for the container to complete before proceeding to the next init container. Instead, the next init container starts immediately after this init container is started, or after any startupProbe has successfully completed.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"volumeMounts": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"mountPath",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "mountPath",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Pod volumes to mount into the container's filesystem. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.VolumeMount"),
									},
								},
							},
						},
					},
					"volumeDevices": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"devicePath",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "devicePath",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "volumeDevices is the list of block devices to be used by the container.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.VolumeDevice"),
									},
								},
							},
						},
					},
					"livenessProbe": {
						SchemaProps: spec.SchemaProps{
							Description: "Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
							Ref:         ref("k8s.io/api/core/v1.Probe"),
						},
					},
					"readinessProbe": {
						SchemaProps: spec.SchemaProps{
							Description: "Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
							Ref:         ref("k8s.io/api/core/v1.Probe"),
						},
					},
					"startupProbe": {
						SchemaProps: spec.SchemaProps{
							Description: "StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
							Ref:         ref("k8s.io/api/core/v1.Probe"),
						},
					},
					"lifecycle": {
						SchemaProps: spec.SchemaProps{
							Description: "Actions that the management system should take in response to container lifecycle events. Cannot be updated.",
							Ref:         ref("k8s.io/api/core/v1.Lifecycle"),
						},
					},
					"terminationMessagePath": {
						SchemaProps: spec.SchemaProps{
							Description: "Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"terminationMessagePolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"imagePullPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"securityContext": {
						SchemaProps: spec.SchemaProps{
							Description: "SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/",
							Ref:         ref("k8s.io/api/core/v1.SecurityContext"),
						},
					},
					"stdin": {
						SchemaProps: spec.SchemaProps{
							Description: "Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"stdinOnce": {
						SchemaProps: spec.SchemaProps{
							Description: "Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"tty": {
						SchemaProps: spec.SchemaProps{
							Description: "Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"podInjectPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "The rules that injected SidecarContainer into Pod.spec.containers, not takes effect in initContainers If BeforeAppContainer, the SidecarContainer will be injected in front of the pod.spec.containers otherwise it will be injected into the back. default BeforeAppContainerType",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"upgradeStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "sidecarContainer upgrade strategy, include: ColdUpgrade, HotUpgrade",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.SidecarContainerUpgradeStrategy"),
						},
					},
					"shareVolumePolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "If ShareVolumePolicy is enabled, the sidecar container will share the other container's VolumeMounts in the pod(don't contains the injected sidecar container).",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.ShareVolumePolicy"),
						},
					},
					"transferEnv": {
						SchemaProps: spec.SchemaProps{
							Description: "TransferEnv will transfer env info from other container SourceContainerName is pod.spec.container[x].name; EnvName is pod.spec.container[x].Env.name",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.TransferEnvVar"),
									},
								},
							},
						},
					},
				},
				Required: []string{"name"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.ShareVolumePolicy", "github.com/openkruise/kruise-api/apps/v1alpha1.SidecarContainerUpgradeStrategy", "github.com/openkruise/kruise-api/apps/v1alpha1.TransferEnvVar", "k8s.io/api/core/v1.ContainerPort", "k8s.io/api/core/v1.ContainerResizePolicy", "k8s.io/api/core/v1.EnvFromSource", "k8s.io/api/core/v1.EnvVar", "k8s.io/api/core/v1.Lifecycle", "k8s.io/api/core/v1.Probe", "k8s.io/api/core/v1.ResourceRequirements", "k8s.io/api/core/v1.SecurityContext", "k8s.io/api/core/v1.VolumeDevice", "k8s.io/api/core/v1.VolumeMount"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_SidecarContainerUpgradeStrategy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"upgradeType": {
						SchemaProps: spec.SchemaProps{
							Description: "when sidecar container is stateless, use ColdUpgrade otherwise HotUpgrade are more HotUpgrade. examples for istio envoy container is suitable for HotUpgrade default is ColdUpgrade",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"hotUpgradeEmptyImage": {
						SchemaProps: spec.SchemaProps{
							Description: "when HotUpgrade, HotUpgradeEmptyImage is used to complete the hot upgrading process HotUpgradeEmptyImage is consistent of sidecar container in Command, Args, Liveness probe, etc. but it does no actual work.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_SidecarSet(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SidecarSet is the Schema for the sidecarsets API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.SidecarSetSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.SidecarSetStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.SidecarSetSpec", "github.com/openkruise/kruise-api/apps/v1alpha1.SidecarSetStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_SidecarSetInjectRevision(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"customVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "CustomVersion corresponds to label 'apps.kruise.io/sidecarset-custom-version' of (History) SidecarSet. SidecarSet will select the specific ControllerRevision via this CustomVersion, and then restore the history SidecarSet to inject specific version of the sidecar to pods.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"revisionName": {
						SchemaProps: spec.SchemaProps{
							Description: "RevisionName corresponds to a specific ControllerRevision name of SidecarSet that you want to inject to Pods.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"policy": {
						SchemaProps: spec.SchemaProps{
							Description: "Policy describes the behavior of revision injection.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_SidecarSetInjectionStrategy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SidecarSetInjectionStrategy indicates the injection strategy of SidecarSet.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"paused": {
						SchemaProps: spec.SchemaProps{
							Description: "Paused indicates that SidecarSet will suspend injection into Pods If Paused is true, the sidecarSet will not be injected to newly created Pods, but the injected sidecar container remains updating and running. default is false",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"revision": {
						SchemaProps: spec.SchemaProps{
							Description: "Revision can help users rolling update SidecarSet safely. If users set this filed, SidecarSet will try to inject specific revision according to different policies.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.SidecarSetInjectRevision"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.SidecarSetInjectRevision"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_SidecarSetList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SidecarSetList contains a list of SidecarSet",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.SidecarSet"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.SidecarSet", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_SidecarSetPatchPodMetadata(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"annotations": {
						SchemaProps: spec.SchemaProps{
							Description: "annotations",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"patchPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "labels map[string]string `json:\"labels,omitempty\"` patch pod metadata policy, Default is \"Retain\"",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_SidecarSetSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SidecarSetSpec defines the desired state of SidecarSet",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"selector": {
						SchemaProps: spec.SchemaProps{
							Description: "selector is a label query over pods that should be injected",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"),
						},
					},
					"namespace": {
						SchemaProps: spec.SchemaProps{
							Description: "Namespace sidecarSet will only match the pods in the namespace otherwise, match pods in all namespaces(in cluster)",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"namespaceSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "NamespaceSelector select which namespaces to inject sidecar containers. Default to the empty LabelSelector, which matches everything.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"),
						},
					},
					"initContainers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "InitContainers is the list of init containers to be injected into the selected pod We will inject those containers by their name in ascending order We only inject init containers when a new pod is created, it does not apply to any existing pod",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.SidecarContainer"),
									},
								},
							},
						},
					},
					"containers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Containers is the list of sidecar containers to be injected into the selected pod",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.SidecarContainer"),
									},
								},
							},
						},
					},
					"volumes": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of volumes that can be mounted by sidecar containers",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Volume"),
									},
								},
							},
						},
					},
					"updateStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "The sidecarset updateStrategy to use to replace existing pods with new ones.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.SidecarSetUpdateStrategy"),
						},
					},
					"injectionStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "InjectionStrategy describe the strategy when sidecarset is injected into pods",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.SidecarSetInjectionStrategy"),
						},
					},
					"imagePullSecrets": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of the names of secrets required by pulling sidecar container images",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.LocalObjectReference"),
									},
								},
							},
						},
					},
					"revisionHistoryLimit": {
						SchemaProps: spec.SchemaProps{
							Description: "RevisionHistoryLimit indicates the maximum quantity of stored revisions about the SidecarSet. default value is 10",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"patchPodMetadata": {
						SchemaProps: spec.SchemaProps{
							Description: "SidecarSet support to inject & in-place update metadata in pod.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.SidecarSetPatchPodMetadata"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.SidecarContainer", "github.com/openkruise/kruise-api/apps/v1alpha1.SidecarSetInjectionStrategy", "github.com/openkruise/kruise-api/apps/v1alpha1.SidecarSetPatchPodMetadata", "github.com/openkruise/kruise-api/apps/v1alpha1.SidecarSetUpdateStrategy", "k8s.io/api/core/v1.LocalObjectReference", "k8s.io/api/core/v1.Volume", "k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_SidecarSetStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SidecarSetStatus defines the observed state of SidecarSet",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "observedGeneration is the most recent generation observed for this SidecarSet. It corresponds to the SidecarSet's generation, which is updated on mutation by the API Server.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"matchedPods": {
						SchemaProps: spec.SchemaProps{
							Description: "matchedPods is the number of Pods whose labels are matched with this SidecarSet's selector and are created after sidecarset creates",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"updatedPods": {
						SchemaProps: spec.SchemaProps{
							Description: "updatedPods is the number of matched Pods that are injected with the latest SidecarSet's containers",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"readyPods": {
						SchemaProps: spec.SchemaProps{
							Description: "readyPods is the number of matched Pods that have a ready condition",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"updatedReadyPods": {
						SchemaProps: spec.SchemaProps{
							Description: "updatedReadyPods is the number of matched pods that updated and ready",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"latestRevision": {
						SchemaProps: spec.SchemaProps{
							Description: "LatestRevision, if not empty, indicates the latest controllerRevision name of the SidecarSet.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"collisionCount": {
						SchemaProps: spec.SchemaProps{
							Description: "CollisionCount is the count of hash collisions for the SidecarSet. The SidecarSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
				Required: []string{"matchedPods", "updatedPods", "readyPods"},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_SidecarSetUpdateStrategy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SidecarSetUpdateStrategy indicates the strategy that the SidecarSet controller will use to perform updates. It includes any additional parameters necessary to perform the update for the indicated strategy.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type is NotUpdate, the SidecarSet don't update the injected pods, it will only inject sidecar container into the newly created pods. Type is RollingUpdate, the SidecarSet will update the injected pods to the latest version on RollingUpdate Strategy. default is RollingUpdate",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"paused": {
						SchemaProps: spec.SchemaProps{
							Description: "Paused indicates that the SidecarSet is paused to update the injected pods, For the impact on the injection behavior for newly created Pods, please refer to the comments of Selector.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"selector": {
						SchemaProps: spec.SchemaProps{
							Description: "If selector is not nil, this upgrade will only update the selected pods.\n\nStarting from Kruise 1.8.0, the updateStrategy.Selector affects the version of the Sidecar container injected into newly created Pods by a SidecarSet configured with an injectionStrategy. In most cases, all newly created Pods are injected with the specified Sidecar version as configured in injectionStrategy.revision, which is consistent with previous versions.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"),
						},
					},
					"partition": {
						SchemaProps: spec.SchemaProps{
							Description: "Partition is the desired number of pods in old revisions. It means when partition is set during pods updating, (replicas - partition) number of pods will be updated. Default value is 0.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"maxUnavailable": {
						SchemaProps: spec.SchemaProps{
							Description: "The maximum number of SidecarSet pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total number of SidecarSet pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up. This cannot be 0. Default value is 1.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"priorityStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "Priorities are the rules for calculating the priority of updating pods. Each pod to be updated, will pass through these terms and get a sum of weights.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/pub.UpdatePriorityStrategy"),
						},
					},
					"scatterStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "ScatterStrategy defines the scatter rules to make pods been scattered when update. This will avoid pods with the same key-value to be updated in one batch. - Note that pods will be scattered after priority sort. So, although priority strategy and scatter strategy can be applied together, we suggest to use either one of them. - If scatterStrategy is used, we suggest to just use one term. Otherwise, the update order can be hard to understand.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.UpdateScatterTerm"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/pub.UpdatePriorityStrategy", "github.com/openkruise/kruise-api/apps/v1alpha1.UpdateScatterTerm", "k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector", "k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_SourceContainerNameSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"fieldRef": {
						SchemaProps: spec.SchemaProps{
							Description: "Selects a field of the pod: supports metadata.name, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,",
							Ref:         ref("k8s.io/api/core/v1.ObjectFieldSelector"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.ObjectFieldSelector"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_StatefulSet(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "StatefulSet is the Schema for the statefulsets API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.StatefulSetSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.StatefulSetStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.StatefulSetSpec", "github.com/openkruise/kruise-api/apps/v1alpha1.StatefulSetStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_StatefulSetList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "StatefulSetList contains a list of StatefulSet",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.StatefulSet"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.StatefulSet", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_StatefulSetSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "StatefulSetSpec defines the desired state of StatefulSet",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"replicas": {
						SchemaProps: spec.SchemaProps{
							Description: "replicas is the desired number of replicas of the given Template. These are replicas in the sense that they are instantiations of the same Template, but individual replicas also have a consistent identity. If unspecified, defaults to 1.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"selector": {
						SchemaProps: spec.SchemaProps{
							Description: "selector is a label query over pods that should match the replica count. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"),
						},
					},
					"template": {
						SchemaProps: spec.SchemaProps{
							Description: "template is the object that describes the pod that will be created if insufficient replicas are detected. Each pod stamped out by the StatefulSet will fulfill this Template, but have a unique identity from the rest of the StatefulSet.",
							Default:     map[string]interface{}{},
							Ref:         ref("k8s.io/api/core/v1.PodTemplateSpec"),
						},
					},
					"volumeClaimTemplates": {
						SchemaProps: spec.SchemaProps{
							Description: "volumeClaimTemplates is a list of claims that pods are allowed to reference. The StatefulSet controller is responsible for mapping network identities to claims in a way that maintains the identity of a pod. Every claim in this list must have at least one matching (by name) volumeMount in one container in the template. A claim in this list takes precedence over any volumes in the template, with the same name.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.PersistentVolumeClaim"),
									},
								},
							},
						},
					},
					"serviceName": {
						SchemaProps: spec.SchemaProps{
							Description: "serviceName is the name of the service that governs this StatefulSet. This service must exist before the StatefulSet, and is responsible for the network identity of the set. Pods get DNS/hostnames that follow the pattern: pod-specific-string.serviceName.default.svc.cluster.local where \"pod-specific-string\" is managed by the StatefulSet controller.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"podManagementPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "podManagementPolicy controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is `OrderedReady`, where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is `Parallel` which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"updateStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.StatefulSetUpdateStrategy"),
						},
					},
					"revisionHistoryLimit": {
						SchemaProps: spec.SchemaProps{
							Description: "revisionHistoryLimit is the maximum number of revisions that will be maintained in the StatefulSet's revision history. The revision history consists of all revisions not represented by a currently applied StatefulSetSpec version. The default value is 10.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
				Required: []string{"selector", "template"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.StatefulSetUpdateStrategy", "k8s.io/api/core/v1.PersistentVolumeClaim", "k8s.io/api/core/v1.PodTemplateSpec", "k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_StatefulSetStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "StatefulSetStatus defines the observed state of StatefulSet",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "observedGeneration is the most recent generation observed for this StatefulSet. It corresponds to the StatefulSet's generation, which is updated on mutation by the API Server.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"replicas": {
						SchemaProps: spec.SchemaProps{
							Description: "replicas is the number of Pods created by the StatefulSet controller.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"readyReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "readyReplicas is the number of Pods created by the StatefulSet controller that have a Ready Condition.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"availableReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "AvailableReplicas is the number of Pods created by the StatefulSet controller that have been ready for minReadySeconds.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"currentReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "currentReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version indicated by currentRevision.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"updatedReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "updatedReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version indicated by updateRevision.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"currentRevision": {
						SchemaProps: spec.SchemaProps{
							Description: "currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence [0,currentReplicas).",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"updateRevision": {
						SchemaProps: spec.SchemaProps{
							Description: "updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence [replicas-updatedReplicas,replicas)",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"collisionCount": {
						SchemaProps: spec.SchemaProps{
							Description: "collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "type",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Represents the latest available observations of a statefulset's current state.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/apps/v1.StatefulSetCondition"),
									},
								},
							},
						},
					},
					"labelSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "LabelSelector is label selectors for query over pods that should match the replica count used by HPA.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"replicas", "readyReplicas", "availableReplicas", "currentReplicas", "updatedReplicas"},
			},
		},
		Dependencies: []string{
			"k8s.io/api/apps/v1.StatefulSetCondition"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_StatefulSetTemplateSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "StatefulSetTemplateSpec defines the subset template of StatefulSet.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/api/apps/v1.StatefulSetSpec"),
						},
					},
				},
				Required: []string{"spec"},
			},
		},
		Dependencies: []string{
			"k8s.io/api/apps/v1.StatefulSetSpec", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_StatefulSetUpdateStrategy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to perform updates. It includes any additional parameters necessary to perform the update for the indicated strategy.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type indicates the type of the StatefulSetUpdateStrategy. Default is RollingUpdate.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"rollingUpdate": {
						SchemaProps: spec.SchemaProps{
							Description: "RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.RollingUpdateStatefulSetStrategy"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.RollingUpdateStatefulSetStrategy"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_Subset(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Subset defines the detail of a subset.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Indicates subset name as a DNS_LABEL, which will be used to generate subset workload name prefix in the format '<deployment-name>-<subset-name>-'. Name should be unique between all of the subsets under one UnitedDeployment.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"nodeSelectorTerm": {
						SchemaProps: spec.SchemaProps{
							Description: "Indicates the node selector to form the subset. Depending on the node selector, pods provisioned could be distributed across multiple groups of nodes. A subset's nodeSelectorTerm is not allowed to be updated.",
							Default:     map[string]interface{}{},
							Ref:         ref("k8s.io/api/core/v1.NodeSelectorTerm"),
						},
					},
					"tolerations": {
						SchemaProps: spec.SchemaProps{
							Description: "Indicates the tolerations the pods under this subset have. A subset's tolerations is not allowed to be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Toleration"),
									},
								},
							},
						},
					},
					"replicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Indicates the number of the pod to be created under this subset. Replicas could also be percentage like '10%', which means 10% of UnitedDeployment replicas of pods will be distributed under this subset. If nil, the number of replicas in this subset is determined by controller. Controller will try to keep all the subsets with nil replicas have average pods. Replicas and MinReplicas/MaxReplicas are mutually exclusive in a UnitedDeployment.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"minReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Indicates the lower bounded replicas of the subset. MinReplicas must be more than or equal to 0 if it is set. Controller will prioritize satisfy minReplicas for each subset according to the order of Topology.Subsets. Defaults to 0.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"maxReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Indicates the upper bounded replicas of the subset. MaxReplicas must be more than or equal to MinReplicas. MaxReplicas == nil means no limitation. Please ensure that at least one subset has empty MaxReplicas(no limitation) to avoid stuck scaling. Defaults to nil.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"patch": {
						SchemaProps: spec.SchemaProps{
							Description: "Patch indicates patching to the templateSpec. Patch takes precedence over other fields If the Patch also modifies the Replicas, NodeSelectorTerm or Tolerations, use value in the Patch",
							Ref:         ref("k8s.io/apimachinery/pkg/runtime.RawExtension"),
						},
					},
				},
				Required: []string{"name"},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.NodeSelectorTerm", "k8s.io/api/core/v1.Toleration", "k8s.io/apimachinery/pkg/runtime.RawExtension", "k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_SubsetTemplate(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SubsetTemplate defines the subset template under the UnitedDeployment. UnitedDeployment will provision every subset based on one workload templates in SubsetTemplate.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"statefulSetTemplate": {
						SchemaProps: spec.SchemaProps{
							Description: "StatefulSet template",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.StatefulSetTemplateSpec"),
						},
					},
					"advancedStatefulSetTemplate": {
						SchemaProps: spec.SchemaProps{
							Description: "AdvancedStatefulSet template",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.AdvancedStatefulSetTemplateSpec"),
						},
					},
					"cloneSetTemplate": {
						SchemaProps: spec.SchemaProps{
							Description: "CloneSet template",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.CloneSetTemplateSpec"),
						},
					},
					"deploymentTemplate": {
						SchemaProps: spec.SchemaProps{
							Description: "Deployment template",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.DeploymentTemplateSpec"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.AdvancedStatefulSetTemplateSpec", "github.com/openkruise/kruise-api/apps/v1alpha1.CloneSetTemplateSpec", "github.com/openkruise/kruise-api/apps/v1alpha1.DeploymentTemplateSpec", "github.com/openkruise/kruise-api/apps/v1alpha1.StatefulSetTemplateSpec"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_SyncStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SyncStatus is summary of the status of all images pulling tasks on the node.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"syncAt": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"message": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_TargetFilter(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "TargetFilter is an optional parameter that allows WorkloadSpread to manage only a subset of the Pods generated by the target workload.\n\nFor example, suppose a WorkloadSpread points to the following Kubeflow TFJob resource:\n\n\t```yaml\n\tapiVersion: kubeflow.org/v1\n\tkind: TFJob\n\tspec:\n\t  tfReplicaSpecs:\n\t\tPS:\n\t\t  replicas: 1\n\t\t  ...\n\t\tMASTER:\n\t\t  replicas: 1\n\t\t  ...\n\t\tWorker:\n\t\t  replicas: 2\n\t\t  ...\n\t```\n\nIf you want to manage only the 2 Worker Pods that are generated, you need to configure the TargetFilter as follows:\n\n\t```yaml\n\ttargetFilter:\n\t  selector:\n\t\tmatchLabels:\n\t\t  role: worker\n\t  replicasPathList:\n\t\t- spec.tfReplicaSpecs.Worker.replicas\n\t```\n\nWith this configuration, the PS Pods and Master Pods generated by the TFJob will not be managed by WorkloadSpread and will not be counted toward the total number of replicas.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"selector": {
						SchemaProps: spec.SchemaProps{
							Description: "Selector is used to filter the Pods to be managed.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"),
						},
					},
					"replicasPathList": {
						SchemaProps: spec.SchemaProps{
							Description: "ReplicasPathList is a list of resource paths used to specify how to determine the total number of replicas of the target workload after filtering. If this list is not empty, WorkloadSpread will look for the corresponding values in the target resource according to each path, and treat the sum of these values as the total number of replicas after filtering.\n\nThe replicas path is a dot-separated path, similar to \"spec.replicas\". If there are arrays, you can use numbers to denote indexes, like \"subsets.1.replicas\". The real values of these paths must be integers.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_TargetReference(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "TargetReference contains enough information to let you identify an workload",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "API version of the referent.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind of the referent.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the referent.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"apiVersion", "kind", "name"},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_Topology(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Topology defines the spread detail of each subset under UnitedDeployment. A UnitedDeployment manages multiple homogeneous workloads which are called subset. Each of subsets under the UnitedDeployment is described in Topology.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"subsets": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Contains the details of each subset. Each element in this array represents one subset which will be provisioned and managed by UnitedDeployment.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.Subset"),
									},
								},
							},
						},
					},
					"scheduleStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "ScheduleStrategy indicates the strategy the UnitedDeployment used to preform the schedule between each of subsets.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.UnitedDeploymentScheduleStrategy"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.Subset", "github.com/openkruise/kruise-api/apps/v1alpha1.UnitedDeploymentScheduleStrategy"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_TransferEnvVar(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"sourceContainerName": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"sourceContainerNameFrom": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("github.com/openkruise/kruise-api/apps/v1alpha1.SourceContainerNameSource"),
						},
					},
					"envName": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"envNames": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.SourceContainerNameSource"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_UnitedDeployment(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "UnitedDeployment is the Schema for the uniteddeployments API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.UnitedDeploymentSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.UnitedDeploymentStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.UnitedDeploymentSpec", "github.com/openkruise/kruise-api/apps/v1alpha1.UnitedDeploymentStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_UnitedDeploymentCondition(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "UnitedDeploymentCondition describes current state of a UnitedDeployment.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type of in place set condition.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Description: "Status of the condition, one of True, False, Unknown.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"lastTransitionTime": {
						SchemaProps: spec.SchemaProps{
							Description: "Last time the condition transitioned from one status to another.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"reason": {
						SchemaProps: spec.SchemaProps{
							Description: "The reason for the condition's last transition.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"message": {
						SchemaProps: spec.SchemaProps{
							Description: "A human-readable message indicating details about the transition.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_UnitedDeploymentList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "UnitedDeploymentList contains a list of UnitedDeployment",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.UnitedDeployment"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.UnitedDeployment", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_UnitedDeploymentScheduleStrategy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "UnitedDeploymentScheduleStrategy defines the schedule performance of UnitedDeployment.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type indicates the type of the UnitedDeploymentScheduleStrategy. Default is Fixed",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"adaptive": {
						SchemaProps: spec.SchemaProps{
							Description: "Adaptive is used to communicate parameters when Type is AdaptiveUnitedDeploymentScheduleStrategyType.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.AdaptiveUnitedDeploymentStrategy"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.AdaptiveUnitedDeploymentStrategy"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_UnitedDeploymentSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "UnitedDeploymentSpec defines the desired state of UnitedDeployment.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"replicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Replicas is the total desired replicas of all the subsets. If unspecified, defaults to 1.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"selector": {
						SchemaProps: spec.SchemaProps{
							Description: "Selector is a label query over pods that should match the replica count. It must match the pod template's labels.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"),
						},
					},
					"template": {
						SchemaProps: spec.SchemaProps{
							Description: "Template describes the subset that will be created.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.SubsetTemplate"),
						},
					},
					"topology": {
						SchemaProps: spec.SchemaProps{
							Description: "Topology describes the pods distribution detail between each of subsets.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.Topology"),
						},
					},
					"updateStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "UpdateStrategy indicates the strategy the UnitedDeployment use to preform the update, when template is changed.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.UnitedDeploymentUpdateStrategy"),
						},
					},
					"revisionHistoryLimit": {
						SchemaProps: spec.SchemaProps{
							Description: "Indicates the number of histories to be conserved. If unspecified, defaults to 10.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
				Required: []string{"selector"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.SubsetTemplate", "github.com/openkruise/kruise-api/apps/v1alpha1.Topology", "github.com/openkruise/kruise-api/apps/v1alpha1.UnitedDeploymentUpdateStrategy", "k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_UnitedDeploymentStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "UnitedDeploymentStatus defines the observed state of UnitedDeployment.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "ObservedGeneration is the most recent generation observed for this UnitedDeployment. It corresponds to the UnitedDeployment's generation, which is updated on mutation by the API Server.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"readyReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of ready replicas.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"replicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Replicas is the most recently observed number of replicas.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"updatedReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of pods in current version.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"updatedReadyReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "The number of ready current revision replicas for this UnitedDeployment.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"collisionCount": {
						SchemaProps: spec.SchemaProps{
							Description: "Count of hash collisions for the UnitedDeployment. The UnitedDeployment controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"currentRevision": {
						SchemaProps: spec.SchemaProps{
							Description: "CurrentRevision, if not empty, indicates the current version of the UnitedDeployment.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"subsetReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Records the topology detail information of the replicas of each subset.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: 0,
										Type:    []string{"integer"},
										Format:  "int32",
									},
								},
							},
						},
					},
					"subsetStatuses": {
						SchemaProps: spec.SchemaProps{
							Description: "Record the conditions of each subset.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.UnitedDeploymentSubsetStatus"),
									},
								},
							},
						},
					},
					"conditions": {
						SchemaProps: spec.SchemaProps{
							Description: "Represents the latest available observations of a UnitedDeployment's current state.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.UnitedDeploymentCondition"),
									},
								},
							},
						},
					},
					"updateStatus": {
						SchemaProps: spec.SchemaProps{
							Description: "Records the information of update progress.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.UpdateStatus"),
						},
					},
					"labelSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "LabelSelector is label selectors for query over pods that should match the replica count used by HPA.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"replicas", "updatedReplicas", "currentRevision"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.UnitedDeploymentCondition", "github.com/openkruise/kruise-api/apps/v1alpha1.UnitedDeploymentSubsetStatus", "github.com/openkruise/kruise-api/apps/v1alpha1.UpdateStatus"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_UnitedDeploymentSubsetCondition(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"lastTransitionTime": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"reason": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"message": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
				Required: []string{"type", "status"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_UnitedDeploymentSubsetStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Subset name specified in Topology.Subsets",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"replicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Recores the current replicas. Currently unused.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"partition": {
						SchemaProps: spec.SchemaProps{
							Description: "Records the current partition. Currently unused.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"conditions": {
						SchemaProps: spec.SchemaProps{
							Description: "Conditions is an array of current observed subset conditions.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.UnitedDeploymentSubsetCondition"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.UnitedDeploymentSubsetCondition"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_UnitedDeploymentUpdateStrategy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "UnitedDeploymentUpdateStrategy defines the update performance when template of UnitedDeployment is changed.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type of UnitedDeployment update strategy. Default is Manual.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"manualUpdate": {
						SchemaProps: spec.SchemaProps{
							Description: "Includes all of the parameters a Manual update strategy needs.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.ManualUpdate"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.ManualUpdate"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_UnorderedUpdateStrategy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "UnorderedUpdateStrategy defines strategies for non-ordered update.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"priorityStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "Priorities are the rules for calculating the priority of updating pods. Each pod to be updated, will pass through these terms and get a sum of weights.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/pub.UpdatePriorityStrategy"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/pub.UpdatePriorityStrategy"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_UpdateScatterTerm(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"key": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"value": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
				},
				Required: []string{"key", "value"},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_UpdateStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "UpdateStatus defines the observed update state of UnitedDeployment.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"updatedRevision": {
						SchemaProps: spec.SchemaProps{
							Description: "Records the latest revision.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"currentPartitions": {
						SchemaProps: spec.SchemaProps{
							Description: "Records the current partition.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: 0,
										Type:    []string{"integer"},
										Format:  "int32",
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_WorkloadSpread(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "WorkloadSpread is the Schema for the WorkloadSpread API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.WorkloadSpreadSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.WorkloadSpreadStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.WorkloadSpreadSpec", "github.com/openkruise/kruise-api/apps/v1alpha1.WorkloadSpreadStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_WorkloadSpreadList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "WorkloadSpreadList contains a list of WorkloadSpread",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.WorkloadSpread"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.WorkloadSpread", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_WorkloadSpreadScheduleStrategy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "WorkloadSpreadScheduleStrategy defines the schedule performance of WorkloadSpread",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type indicates the type of the WorkloadSpreadScheduleStrategy. Default is Fixed",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"adaptive": {
						SchemaProps: spec.SchemaProps{
							Description: "Adaptive is used to communicate parameters when Type is AdaptiveWorkloadSpreadScheduleStrategyType.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.AdaptiveWorkloadSpreadStrategy"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.AdaptiveWorkloadSpreadStrategy"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_WorkloadSpreadSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "WorkloadSpreadSpec defines the desired state of WorkloadSpread.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"targetRef": {
						SchemaProps: spec.SchemaProps{
							Description: "TargetReference is the target workload that WorkloadSpread want to control.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.TargetReference"),
						},
					},
					"targetFilter": {
						SchemaProps: spec.SchemaProps{
							Description: "TargetFilter allows WorkloadSpread to manage only a portion of the Pods in the TargetReference: by specifying the criteria for the Pods to be managed through a label selector, and by specifying how to obtain the total number of these selected Pods from the workload using replicasPaths.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.TargetFilter"),
						},
					},
					"subsets": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Subsets describes the pods distribution details between each of subsets.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.WorkloadSpreadSubset"),
									},
								},
							},
						},
					},
					"scheduleStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "ScheduleStrategy indicates the strategy the WorkloadSpread used to preform the schedule between each of subsets.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1alpha1.WorkloadSpreadScheduleStrategy"),
						},
					},
				},
				Required: []string{"targetRef", "subsets"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.TargetFilter", "github.com/openkruise/kruise-api/apps/v1alpha1.TargetReference", "github.com/openkruise/kruise-api/apps/v1alpha1.WorkloadSpreadScheduleStrategy", "github.com/openkruise/kruise-api/apps/v1alpha1.WorkloadSpreadSubset"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_WorkloadSpreadStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "WorkloadSpreadStatus defines the observed state of WorkloadSpread.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "ObservedGeneration is the most recent generation observed for this WorkloadSpread. It corresponds to the WorkloadSpread's generation, which is updated on mutation by the API Server.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"subsetStatuses": {
						SchemaProps: spec.SchemaProps{
							Description: "Contains the status of each subset. Each element in this array represents one subset",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.WorkloadSpreadSubsetStatus"),
									},
								},
							},
						},
					},
					"versionedSubsetStatuses": {
						SchemaProps: spec.SchemaProps{
							Description: "VersionedSubsetStatuses is to solve rolling-update problems, where the creation of new-version pod may be earlier than deletion of old-version pod. We have to calculate the pod subset distribution for each version.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type: []string{"array"},
										Items: &spec.SchemaOrArray{
											Schema: &spec.Schema{
												SchemaProps: spec.SchemaProps{
													Default: map[string]interface{}{},
													Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.WorkloadSpreadSubsetStatus"),
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.WorkloadSpreadSubsetStatus"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_WorkloadSpreadSubset(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "WorkloadSpreadSubset defines the details of a subset.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name should be unique between all of the subsets under one WorkloadSpread.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"requiredNodeSelectorTerm": {
						SchemaProps: spec.SchemaProps{
							Description: "Indicates the node required selector to form the subset.",
							Ref:         ref("k8s.io/api/core/v1.NodeSelectorTerm"),
						},
					},
					"preferredNodeSelectorTerms": {
						SchemaProps: spec.SchemaProps{
							Description: "Indicates the node preferred selector to form the subset.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.PreferredSchedulingTerm"),
									},
								},
							},
						},
					},
					"tolerations": {
						SchemaProps: spec.SchemaProps{
							Description: "Indicates the tolerations the pods under this subset have.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Toleration"),
									},
								},
							},
						},
					},
					"maxReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxReplicas indicates the desired max replicas of this subset.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"patch": {
						SchemaProps: spec.SchemaProps{
							Description: "Patch indicates patching podTemplate to the Pod.",
							Ref:         ref("k8s.io/apimachinery/pkg/runtime.RawExtension"),
						},
					},
				},
				Required: []string{"name"},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.NodeSelectorTerm", "k8s.io/api/core/v1.PreferredSchedulingTerm", "k8s.io/api/core/v1.Toleration", "k8s.io/apimachinery/pkg/runtime.RawExtension", "k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_WorkloadSpreadSubsetCondition(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type of in place set condition.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Description: "Status of the condition, one of True, False, Unknown.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"lastTransitionTime": {
						SchemaProps: spec.SchemaProps{
							Description: "Last time the condition transitioned from one status to another.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"reason": {
						SchemaProps: spec.SchemaProps{
							Description: "The reason for the condition's last transition.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"message": {
						SchemaProps: spec.SchemaProps{
							Description: "A human readable message indicating details about the transition.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"type", "status"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_openkruise_kruise_api_apps_v1alpha1_WorkloadSpreadSubsetStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "WorkloadSpreadSubsetStatus defines the observed state of subset",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name should be unique between all of the subsets under one WorkloadSpread.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"replicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Replicas is the most recently observed number of active replicas for subset.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"conditions": {
						SchemaProps: spec.SchemaProps{
							Description: "Conditions is an array of current observed subset conditions.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1alpha1.WorkloadSpreadSubsetCondition"),
									},
								},
							},
						},
					},
					"missingReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "MissingReplicas is the number of active replicas belong to this subset not be found. MissingReplicas > 0 indicates the subset is still missing MissingReplicas pods to create MissingReplicas = 0 indicates the subset already has enough pods, there is no need to create MissingReplicas = -1 indicates the subset's MaxReplicas not set, then there is no limit for pods number",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"creatingPods": {
						SchemaProps: spec.SchemaProps{
							Description: "CreatingPods contains information about pods whose creation was processed by the webhook handler but not yet been observed by the WorkloadSpread controller. A pod will be in this map from the time when the webhook handler processed the creation request to the time when the pod is seen by controller. The key in the map is the name of the pod and the value is the time when the webhook handler process the creation request. If the real creation didn't happen and a pod is still in this map, it will be removed from the list automatically by WorkloadSpread controller after some time. If everything goes smooth this map should be empty for the most of the time. Large number of entries in the map may indicate problems with pod creations.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
									},
								},
							},
						},
					},
					"deletingPods": {
						SchemaProps: spec.SchemaProps{
							Description: "DeletingPods is similar with CreatingPods and it contains information about pod deletion.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
									},
								},
							},
						},
					},
				},
				Required: []string{"name", "replicas", "missingReplicas"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1alpha1.WorkloadSpreadSubsetCondition", "k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_openkruise_kruise_api_apps_v1beta1_RollingUpdateStatefulSetStrategy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RollingUpdateStatefulSetStrategy is used to communicate parameter for RollingUpdateStatefulSetStrategyType.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"partition": {
						SchemaProps: spec.SchemaProps{
							Description: "Partition indicates the number of pods the StatefulSet should be partitioned by default.\n  - It means controller will update $(replicas - partition) number of pod.\nDefault value is 0.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"maxUnavailable": {
						SchemaProps: spec.SchemaProps{
							Description: "The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. Also, maxUnavailable can just be allowed to work with Parallel podManagementPolicy. Defaults to 1.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"podUpdatePolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "PodUpdatePolicy indicates how pods should be updated Default value is \"ReCreate\"",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"paused": {
						SchemaProps: spec.SchemaProps{
							Description: "Paused indicates that the StatefulSet is paused. Default value is false",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"unorderedUpdate": {
						SchemaProps: spec.SchemaProps{
							Description: "UnorderedUpdate contains strategies for non-ordered update. If it is not nil, pods will be updated with non-ordered sequence. Noted that UnorderedUpdate can only be allowed to work with Parallel podManagementPolicy",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1beta1.UnorderedUpdateStrategy"),
						},
					},
					"inPlaceUpdateStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "InPlaceUpdateStrategy contains strategies for in-place update.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/pub.InPlaceUpdateStrategy"),
						},
					},
					"minReadySeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "MinReadySeconds indicates how long will the pod be considered ready after it's updated. MinReadySeconds works with both OrderedReady and Parallel podManagementPolicy. It affects the pod scale up speed when the podManagementPolicy is set to be OrderedReady. Combined with MaxUnavailable, it affects the pod update speed regardless of podManagementPolicy. Default value is 0, max is 300.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/pub.InPlaceUpdateStrategy", "github.com/openkruise/kruise-api/apps/v1beta1.UnorderedUpdateStrategy", "k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema_openkruise_kruise_api_apps_v1beta1_StatefulSet(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "StatefulSet is the Schema for the statefulsets API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1beta1.StatefulSetSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/apps/v1beta1.StatefulSetStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1beta1.StatefulSetSpec", "github.com/openkruise/kruise-api/apps/v1beta1.StatefulSetStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1beta1_StatefulSetList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "StatefulSetList contains a list of StatefulSet",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1beta1.StatefulSet"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1beta1.StatefulSet", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_openkruise_kruise_api_apps_v1beta1_StatefulSetOrdinals(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "StatefulSetOrdinals describes the policy used for replica ordinal assignment in this StatefulSet.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"start": {
						SchemaProps: spec.SchemaProps{
							Description: "start is the number representing the first replica's index. It may be used to number replicas from an alternate index (eg: 1-indexed) over the default 0-indexed names, or to orchestrate progressive movement of replicas from one StatefulSet to another. If set, replica indices will be in the range:\n  [.spec.ordinals.start, .spec.ordinals.start + .spec.replicas).\nIf unset, defaults to 0. Replica indices will be in the range:\n  [0, .spec.replicas).",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1beta1_StatefulSetPersistentVolumeClaimRetentionPolicy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "StatefulSetPersistentVolumeClaimRetentionPolicy describes the policy used for PVCs created from the StatefulSet VolumeClaims.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"whenDeleted": {
						SchemaProps: spec.SchemaProps{
							Description: "WhenDeleted specifies what happens to PVCs created from StatefulSet VolumeClaimTemplates when the StatefulSet is deleted. The default policy of `Retain` causes PVCs to not be affected by StatefulSet deletion. The `Delete` policy causes those PVCs to be deleted.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"whenScaled": {
						SchemaProps: spec.SchemaProps{
							Description: "WhenScaled specifies what happens to PVCs created from StatefulSet VolumeClaimTemplates when the StatefulSet is scaled down. The default policy of `Retain` causes PVCs to not be affected by a scaledown. The `Delete` policy causes the associated PVCs for any excess pods above the replica count to be deleted.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1beta1_StatefulSetScaleStrategy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "StatefulSetScaleStrategy defines strategies for pods scale.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"maxUnavailable": {
						SchemaProps: spec.SchemaProps{
							Description: "The maximum number of pods that can be unavailable during scaling. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. It can just be allowed to work with Parallel podManagementPolicy.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema_openkruise_kruise_api_apps_v1beta1_StatefulSetSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "StatefulSetSpec defines the desired state of StatefulSet",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"replicas": {
						SchemaProps: spec.SchemaProps{
							Description: "replicas is the desired number of replicas of the given Template. These are replicas in the sense that they are instantiations of the same Template, but individual replicas also have a consistent identity. If unspecified, defaults to 1.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"selector": {
						SchemaProps: spec.SchemaProps{
							Description: "selector is a label query over pods that should match the replica count. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"),
						},
					},
					"template": {
						SchemaProps: spec.SchemaProps{
							Description: "template is the object that describes the pod that will be created if insufficient replicas are detected. Each pod stamped out by the StatefulSet will fulfill this Template, but have a unique identity from the rest of the StatefulSet.",
							Default:     map[string]interface{}{},
							Ref:         ref("k8s.io/api/core/v1.PodTemplateSpec"),
						},
					},
					"volumeClaimTemplates": {
						SchemaProps: spec.SchemaProps{
							Description: "volumeClaimTemplates is a list of claims that pods are allowed to reference. The StatefulSet controller is responsible for mapping network identities to claims in a way that maintains the identity of a pod. Every claim in this list must have at least one matching (by name) volumeMount in one container in the template. A claim in this list takes precedence over any volumes in the template, with the same name.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.PersistentVolumeClaim"),
									},
								},
							},
						},
					},
					"volumeClaimUpdateStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "VolumeClaimUpdateStrategy specifies the strategy for updating VolumeClaimTemplates within a StatefulSet. This field is currently only effective if the StatefulSetAutoResizePVCGate is enabled.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1beta1.VolumeClaimUpdateStrategy"),
						},
					},
					"serviceName": {
						SchemaProps: spec.SchemaProps{
							Description: "serviceName is the name of the service that governs this StatefulSet. This service must exist before the StatefulSet, and is responsible for the network identity of the set. Pods get DNS/hostnames that follow the pattern: pod-specific-string.serviceName.default.svc.cluster.local where \"pod-specific-string\" is managed by the StatefulSet controller.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"podManagementPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "podManagementPolicy controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is `OrderedReady`, where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is `Parallel` which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"updateStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1beta1.StatefulSetUpdateStrategy"),
						},
					},
					"revisionHistoryLimit": {
						SchemaProps: spec.SchemaProps{
							Description: "revisionHistoryLimit is the maximum number of revisions that will be maintained in the StatefulSet's revision history. The revision history consists of all revisions not represented by a currently applied StatefulSetSpec version. The default value is 10.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"reserveOrdinals": {
						SchemaProps: spec.SchemaProps{
							Description: "reserveOrdinals controls the ordinal numbers that should be reserved, and the replicas will always be the expectation number of running Pods. For a sts with replicas=3 and its Pods in [0, 1, 2]: - If you want to migrate Pod-1 and reserve this ordinal, just set spec.reserveOrdinal to [1].\n  Then controller will delete Pod-1 and create Pod-3 (existing Pods will be [0, 2, 3])\n- If you just want to delete Pod-1, you should set spec.reserveOrdinal to [1] and spec.replicas to 2.\n  Then controller will delete Pod-1 (existing Pods will be [0, 2])\nYou can also use ranges along with numbers, such as [1, 3-5], which is a shortcut for [1, 3, 4, 5].",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
									},
								},
							},
						},
					},
					"lifecycle": {
						SchemaProps: spec.SchemaProps{
							Description: "Lifecycle defines the lifecycle hooks for Pods pre-delete, in-place update.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/pub.Lifecycle"),
						},
					},
					"scaleStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "scaleStrategy indicates the StatefulSetScaleStrategy that will be employed to scale Pods in the StatefulSet.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1beta1.StatefulSetScaleStrategy"),
						},
					},
					"persistentVolumeClaimRetentionPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "PersistentVolumeClaimRetentionPolicy describes the policy used for PVCs created from the StatefulSet VolumeClaimTemplates. This requires the StatefulSetAutoDeletePVC feature gate to be enabled, which is alpha.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1beta1.StatefulSetPersistentVolumeClaimRetentionPolicy"),
						},
					},
					"ordinals": {
						SchemaProps: spec.SchemaProps{
							Description: "ordinals controls the numbering of replica indices in a StatefulSet. The default ordinals behavior assigns a \"0\" index to the first replica and increments the index by one for each additional replica requested. Using the ordinals field requires the StatefulSetStartOrdinal feature gate to be enabled, which is beta.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1beta1.StatefulSetOrdinals"),
						},
					},
				},
				Required: []string{"selector", "template"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/pub.Lifecycle", "github.com/openkruise/kruise-api/apps/v1beta1.StatefulSetOrdinals", "github.com/openkruise/kruise-api/apps/v1beta1.StatefulSetPersistentVolumeClaimRetentionPolicy", "github.com/openkruise/kruise-api/apps/v1beta1.StatefulSetScaleStrategy", "github.com/openkruise/kruise-api/apps/v1beta1.StatefulSetUpdateStrategy", "github.com/openkruise/kruise-api/apps/v1beta1.VolumeClaimUpdateStrategy", "k8s.io/api/core/v1.PersistentVolumeClaim", "k8s.io/api/core/v1.PodTemplateSpec", "k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector", "k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema_openkruise_kruise_api_apps_v1beta1_StatefulSetStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "StatefulSetStatus defines the observed state of StatefulSet",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "observedGeneration is the most recent generation observed for this StatefulSet. It corresponds to the StatefulSet's generation, which is updated on mutation by the API Server.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"replicas": {
						SchemaProps: spec.SchemaProps{
							Description: "replicas is the number of Pods created by the StatefulSet controller.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"readyReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "readyReplicas is the number of Pods created by the StatefulSet controller that have a Ready Condition.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"availableReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "AvailableReplicas is the number of Pods created by the StatefulSet controller that have been ready for minReadySeconds.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"currentReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "currentReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version indicated by currentRevision.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"updatedReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "updatedReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version indicated by updateRevision.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"updatedReadyReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "updatedReadyReplicas is the number of updated Pods created by the StatefulSet controller that have a Ready Condition.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"updatedAvailableReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "updatedAvailableReplicas is the number of updated Pods created by the StatefulSet controller that have a Ready condition for atleast minReadySeconds.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"currentRevision": {
						SchemaProps: spec.SchemaProps{
							Description: "currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence [0,currentReplicas).",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"updateRevision": {
						SchemaProps: spec.SchemaProps{
							Description: "updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence [replicas-updatedReplicas,replicas)",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"collisionCount": {
						SchemaProps: spec.SchemaProps{
							Description: "collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "type",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Represents the latest available observations of a statefulset's current state.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/apps/v1.StatefulSetCondition"),
									},
								},
							},
						},
					},
					"labelSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "LabelSelector is label selectors for query over pods that should match the replica count used by HPA.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"volumeClaims": {
						SchemaProps: spec.SchemaProps{
							Description: "VolumeClaims represents the status of compatibility between existing PVCs and their respective templates. It tracks whether the PersistentVolumeClaims have been updated to match any changes made to the volumeClaimTemplates, ensuring synchronization between the defined templates and the actual PersistentVolumeClaims in use.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/apps/v1beta1.VolumeClaimStatus"),
									},
								},
							},
						},
					},
				},
				Required: []string{"replicas", "readyReplicas", "availableReplicas", "currentReplicas", "updatedReplicas"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1beta1.VolumeClaimStatus", "k8s.io/api/apps/v1.StatefulSetCondition"},
	}
}

func schema_openkruise_kruise_api_apps_v1beta1_StatefulSetUpdateStrategy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to perform updates. It includes any additional parameters necessary to perform the update for the indicated strategy.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type indicates the type of the StatefulSetUpdateStrategy. Default is RollingUpdate.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"rollingUpdate": {
						SchemaProps: spec.SchemaProps{
							Description: "RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/v1beta1.RollingUpdateStatefulSetStrategy"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/v1beta1.RollingUpdateStatefulSetStrategy"},
	}
}

func schema_openkruise_kruise_api_apps_v1beta1_UnorderedUpdateStrategy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "UnorderedUpdateStrategy defines strategies for non-ordered update.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"priorityStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "Priorities are the rules for calculating the priority of updating pods. Each pod to be updated, will pass through these terms and get a sum of weights.",
							Ref:         ref("github.com/openkruise/kruise-api/apps/pub.UpdatePriorityStrategy"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/apps/pub.UpdatePriorityStrategy"},
	}
}

func schema_openkruise_kruise_api_apps_v1beta1_VolumeClaimStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "VolumeClaimStatus describes the status of a volume claim template. It provides details about the compatibility and readiness of the volume claim.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"volumeClaimName": {
						SchemaProps: spec.SchemaProps{
							Description: "VolumeClaimName is the name of the volume claim. This is a unique identifier used to reference a specific volume claim.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"compatibleReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "CompatibleReplicas is the number of replicas currently compatible with the volume claim. It indicates how many replicas can function properly, being compatible with this volume claim. Compatibility is determined by whether the PVC spec storage requests are greater than or equal to the template spec storage requests",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"compatibleReadyReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "CompatibleReadyReplicas is the number of replicas that are both ready and compatible with the volume claim. It highlights that these replicas are not only compatible but also ready to be put into service immediately. Compatibility is determined by whether the pvc spec storage requests are greater than or equal to the template spec storage requests The \"ready\" status is determined by whether the PVC status capacity is greater than or equal to the PVC spec storage requests.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
				Required: []string{"volumeClaimName", "compatibleReplicas", "compatibleReadyReplicas"},
			},
		},
	}
}

func schema_openkruise_kruise_api_apps_v1beta1_VolumeClaimUpdateStrategy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "VolumeClaimUpdateStrategy defines the strategy for updating volume claims. This structure is used to control how updates to PersistentVolumeClaims are handled during pod rolling updates or PersistentVolumeClaim deletions.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type specifies the type of update strategy, possible values include: OnPodRollingUpdateVolumeClaimUpdateStrategyType: Apply the update strategy during pod rolling updates. OnPVCDeleteVolumeClaimUpdateStrategyType: Apply the update strategy when a PersistentVolumeClaim is deleted.\n\nPossible enum values:\n - `\"OnDelete\"` indicates that updates are triggered when a Persistent Volume Claim (PVC) is deleted. This strategy places full control of the update timing in the hands of the user, typically executed after ensuring data has been backed up or there are no data security concerns, allowing for storage resource management that aligns with specific user requirements and security policies.\n - `\"OnPodRollingUpdate\"` indicates that volume claim updates are triggered when associated Pods undergo rolling updates. This strategy ensures that storage availability and integrity are maintained during the update process.",
							Type:        []string{"string"},
							Format:      "",
							Enum:        []interface{}{"OnDelete", "OnPodRollingUpdate"},
						},
					},
				},
			},
		},
	}
}

func schema_openkruise_kruise_api_policy_v1alpha1_PodUnavailableBudget(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PodUnavailableBudget is the Schema for the podunavailablebudgets API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/policy/v1alpha1.PodUnavailableBudgetSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/openkruise/kruise-api/policy/v1alpha1.PodUnavailableBudgetStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/policy/v1alpha1.PodUnavailableBudgetSpec", "github.com/openkruise/kruise-api/policy/v1alpha1.PodUnavailableBudgetStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_openkruise_kruise_api_policy_v1alpha1_PodUnavailableBudgetList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PodUnavailableBudgetList contains a list of PodUnavailableBudget",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/openkruise/kruise-api/policy/v1alpha1.PodUnavailableBudget"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/policy/v1alpha1.PodUnavailableBudget", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_openkruise_kruise_api_policy_v1alpha1_PodUnavailableBudgetSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PodUnavailableBudgetSpec defines the desired state of PodUnavailableBudget",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"selector": {
						SchemaProps: spec.SchemaProps{
							Description: "Selector label query over pods managed by the budget",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"),
						},
					},
					"targetRef": {
						SchemaProps: spec.SchemaProps{
							Description: "TargetReference contains enough information to let you identify an workload for PodUnavailableBudget Selector and TargetReference are mutually exclusive, TargetReference is priority to take effect",
							Ref:         ref("github.com/openkruise/kruise-api/policy/v1alpha1.TargetReference"),
						},
					},
					"maxUnavailable": {
						SchemaProps: spec.SchemaProps{
							Description: "Delete pod, evict pod or update pod specification is allowed if at most \"maxUnavailable\" pods selected by \"selector\" or \"targetRef\"  are unavailable after the above operation for pod. MaxUnavailable and MinAvailable are mutually exclusive, MaxUnavailable is priority to take effect",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"minAvailable": {
						SchemaProps: spec.SchemaProps{
							Description: "Delete pod, evict pod or update pod specification is allowed if at least \"minAvailable\" pods selected by \"selector\" or \"targetRef\" will still be available after the above operation for pod.",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/openkruise/kruise-api/policy/v1alpha1.TargetReference", "k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector", "k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema_openkruise_kruise_api_policy_v1alpha1_PodUnavailableBudgetStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PodUnavailableBudgetStatus defines the observed state of PodUnavailableBudget",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "Most recent generation observed when updating this PUB status. UnavailableAllowed and other status information is valid only if observedGeneration equals to PUB's object generation.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"disruptedPods": {
						SchemaProps: spec.SchemaProps{
							Description: "DisruptedPods contains information about pods whose eviction or deletion was processed by the API handler but has not yet been observed by the PodUnavailableBudget.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
									},
								},
							},
						},
					},
					"unavailablePods": {
						SchemaProps: spec.SchemaProps{
							Description: "UnavailablePods contains information about pods whose specification changed(inplace-update pod), once pod is available(consistent and ready) again, it will be removed from the list.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
									},
								},
							},
						},
					},
					"unavailableAllowed": {
						SchemaProps: spec.SchemaProps{
							Description: "UnavailableAllowed number of pod unavailable that are currently allowed",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"currentAvailable": {
						SchemaProps: spec.SchemaProps{
							Description: "CurrentAvailable current number of available pods",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"desiredAvailable": {
						SchemaProps: spec.SchemaProps{
							Description: "DesiredAvailable minimum desired number of available pods",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"totalReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "TotalReplicas total number of pods counted by this unavailable budget",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
				Required: []string{"unavailableAllowed", "currentAvailable", "desiredAvailable", "totalReplicas"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_openkruise_kruise_api_policy_v1alpha1_TargetReference(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "TargetReference contains enough information to let you identify an workload for PodUnavailableBudget",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "API version of the referent.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind of the referent.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the referent.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_APIGroup(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "APIGroup contains the name, the supported versions, and the preferred version of a group.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "name is the name of the group.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"versions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "versions are the versions supported in this group.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.GroupVersionForDiscovery"),
									},
								},
							},
						},
					},
					"preferredVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "preferredVersion is the version preferred by the API server, which probably is the storage version.",
							Default:     map[string]interface{}{},
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.GroupVersionForDiscovery"),
						},
					},
					"serverAddressByClientCIDRs": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "a map of client CIDR to server address that is serving this group. This is to help clients reach servers in the most network-efficient way possible. Clients can use the appropriate server address as per the CIDR that they match. In case of multiple matches, clients should use the longest matching CIDR. The server returns only those CIDRs that it thinks that the client can match. For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP. Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ServerAddressByClientCIDR"),
									},
								},
							},
						},
					},
				},
				Required: []string{"name", "versions"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.GroupVersionForDiscovery", "k8s.io/apimachinery/pkg/apis/meta/v1.ServerAddressByClientCIDR"},
	}
}

func schema_pkg_apis_meta_v1_APIGroupList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "APIGroupList is a list of APIGroup, to allow clients to discover the API at /apis.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"groups": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "groups is a list of APIGroup.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.APIGroup"),
									},
								},
							},
						},
					},
				},
				Required: []string{"groups"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.APIGroup"},
	}
}

func schema_pkg_apis_meta_v1_APIResource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "APIResource specifies the name of a resource and whether it is namespaced.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "name is the plural name of the resource.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"singularName": {
						SchemaProps: spec.SchemaProps{
							Description: "singularName is the singular name of the resource.  This allows clients to handle plural and singular opaquely. The singularName is more correct for reporting status on a single item and both singular and plural are allowed from the kubectl CLI interface.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"namespaced": {
						SchemaProps: spec.SchemaProps{
							Description: "namespaced indicates if a resource is namespaced or not.",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"group": {
						SchemaProps: spec.SchemaProps{
							Description: "group is the preferred group of the resource.  Empty implies the group of the containing resource list. For subresources, this may have a different value, for example: Scale\".",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"version": {
						SchemaProps: spec.SchemaProps{
							Description: "version is the preferred version of the resource.  Empty implies the version of the containing resource list For subresources, this may have a different value, for example: v1 (while inside a v1beta1 version of the core resource's group)\".",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"verbs": {
						SchemaProps: spec.SchemaProps{
							Description: "verbs is a list of supported kube verbs (this includes get, list, watch, create, update, patch, delete, deletecollection, and proxy)",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"shortNames": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "shortNames is a list of suggested short names of the resource.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"categories": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "categories is a list of the grouped resources this resource belongs to (e.g. 'all')",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"storageVersionHash": {
						SchemaProps: spec.SchemaProps{
							Description: "The hash value of the storage version, the version this resource is converted to when written to the data store. Value must be treated as opaque by clients. Only equality comparison on the value is valid. This is an alpha feature and may change or be removed in the future. The field is populated by the apiserver only if the StorageVersionHash feature gate is enabled. This field will remain optional even if it graduates.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"name", "singularName", "namespaced", "kind", "verbs"},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_APIResourceList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"groupVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "groupVersion is the group and version this APIResourceList is for.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"resources": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "resources contains the name of the resources and if they are namespaced.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.APIResource"),
									},
								},
							},
						},
					},
				},
				Required: []string{"groupVersion", "resources"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.APIResource"},
	}
}

func schema_pkg_apis_meta_v1_APIVersions(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "APIVersions lists the versions that are available, to allow clients to discover the API at /api, which is the root path of the legacy v1 API.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"versions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "versions are the api versions that are available.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"serverAddressByClientCIDRs": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "a map of client CIDR to server address that is serving this group. This is to help clients reach servers in the most network-efficient way possible. Clients can use the appropriate server address as per the CIDR that they match. In case of multiple matches, clients should use the longest matching CIDR. The server returns only those CIDRs that it thinks that the client can match. For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP. Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ServerAddressByClientCIDR"),
									},
								},
							},
						},
					},
				},
				Required: []string{"versions", "serverAddressByClientCIDRs"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ServerAddressByClientCIDR"},
	}
}

func schema_pkg_apis_meta_v1_ApplyOptions(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ApplyOptions may be provided when applying an API object. FieldManager is required for apply requests. ApplyOptions is equivalent to PatchOptions. It is provided as a convenience with documentation that speaks specifically to how the options fields relate to apply.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"dryRun": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"force": {
						SchemaProps: spec.SchemaProps{
							Description: "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people.",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"fieldManager": {
						SchemaProps: spec.SchemaProps{
							Description: "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"force", "fieldManager"},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_Condition(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Condition contains details for one aspect of the current state of this API Resource.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "type of condition in CamelCase or in foo.example.com/CamelCase.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Description: "status of the condition, one of True, False, Unknown.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"lastTransitionTime": {
						SchemaProps: spec.SchemaProps{
							Description: "lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"reason": {
						SchemaProps: spec.SchemaProps{
							Description: "reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"message": {
						SchemaProps: spec.SchemaProps{
							Description: "message is a human readable message indicating details about the transition. This may be an empty string.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"type", "status", "lastTransitionTime", "reason", "message"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_pkg_apis_meta_v1_CreateOptions(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CreateOptions may be provided when creating an API object.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"dryRun": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"fieldManager": {
						SchemaProps: spec.SchemaProps{
							Description: "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"fieldValidation": {
						SchemaProps: spec.SchemaProps{
							Description: "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_DeleteOptions(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "DeleteOptions may be provided when deleting an API object.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"gracePeriodSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"preconditions": {
						SchemaProps: spec.SchemaProps{
							Description: "Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be returned.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Preconditions"),
						},
					},
					"orphanDependents": {
						SchemaProps: spec.SchemaProps{
							Description: "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"propagationPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"dryRun": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Preconditions"},
	}
}

func schema_pkg_apis_meta_v1_Duration(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Duration is a wrapper around time.Duration which supports correct marshaling to YAML and JSON. In particular, it marshals into strings, which can be used as map keys in json.",
				Type:        v1.Duration{}.OpenAPISchemaType(),
				Format:      v1.Duration{}.OpenAPISchemaFormat(),
			},
		},
	}
}

func schema_pkg_apis_meta_v1_FieldsV1(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.\n\nEach key is either a '.' representing the field itself, and will always map to an empty set, or a string representing a sub-field or item. The string will follow one of these four formats: 'f:<name>', where <name> is the name of a field in a struct, or key in a map 'v:<value>', where <value> is the exact json formatted value of a list item 'i:<index>', where <index> is position of a item in a list 'k:<keys>', where <keys> is a map of  a list item's key fields to their unique values If a key maps to an empty Fields value, the field that key represents is part of the set.\n\nThe exact format is defined in sigs.k8s.io/structured-merge-diff",
				Type:        []string{"object"},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_GetOptions(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GetOptions is the standard query options to the standard REST get call.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"resourceVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_GroupKind(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GroupKind specifies a Group and a Kind, but does not force a version.  This is useful for identifying concepts during lookup stages without having partially valid types",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"group": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"kind": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
				},
				Required: []string{"group", "kind"},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_GroupResource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GroupResource specifies a Group and a Resource, but does not force a version.  This is useful for identifying concepts during lookup stages without having partially valid types",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"group": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"resource": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
				},
				Required: []string{"group", "resource"},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_GroupVersion(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GroupVersion contains the \"group\" and the \"version\", which uniquely identifies the API.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"group": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"version": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
				},
				Required: []string{"group", "version"},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_GroupVersionForDiscovery(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GroupVersion contains the \"group/version\" and \"version\" string of a version. It is made a struct to keep extensibility.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"groupVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "groupVersion specifies the API group and version in the form \"group/version\"",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"version": {
						SchemaProps: spec.SchemaProps{
							Description: "version specifies the version in the form of \"version\". This is to save the clients the trouble of splitting the GroupVersion.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"groupVersion", "version"},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_GroupVersionKind(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GroupVersionKind unambiguously identifies a kind.  It doesn't anonymously include GroupVersion to avoid automatic coercion.  It doesn't use a GroupVersion to avoid custom marshalling",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"group": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"version": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"kind": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
				},
				Required: []string{"group", "version", "kind"},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_GroupVersionResource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GroupVersionResource unambiguously identifies a resource.  It doesn't anonymously include GroupVersion to avoid automatic coercion.  It doesn't use a GroupVersion to avoid custom marshalling",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"group": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"version": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"resource": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
				},
				Required: []string{"group", "version", "resource"},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_InternalEvent(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "InternalEvent makes watch.Event versioned",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"Type": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"Object": {
						SchemaProps: spec.SchemaProps{
							Description: "Object is:\n * If Type is Added or Modified: the new state of the object.\n * If Type is Deleted: the state of the object immediately before deletion.\n * If Type is Bookmark: the object (instance of a type being watched) where\n   only ResourceVersion field is set. On successful restart of watch from a\n   bookmark resourceVersion, client is guaranteed to not get repeat event\n   nor miss any events.\n * If Type is Error: *api.Status is recommended; other types may make sense\n   depending on context.",
							Ref:         ref("k8s.io/apimachinery/pkg/runtime.Object"),
						},
					},
				},
				Required: []string{"Type", "Object"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/runtime.Object"},
	}
}

func schema_pkg_apis_meta_v1_LabelSelector(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"matchLabels": {
						SchemaProps: spec.SchemaProps{
							Description: "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"matchExpressions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelectorRequirement"),
									},
								},
							},
						},
					},
				},
			},
			VendorExtensible: spec.VendorExtensible{
				Extensions: spec.Extensions{
					"x-kubernetes-map-type": "atomic",
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelectorRequirement"},
	}
}

func schema_pkg_apis_meta_v1_LabelSelectorRequirement(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"key": {
						SchemaProps: spec.SchemaProps{
							Description: "key is the label key that the selector applies to.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"operator": {
						SchemaProps: spec.SchemaProps{
							Description: "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"values": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
				Required: []string{"key", "operator"},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_List(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "List holds a list of objects, which may not be known by the server.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Default:     map[string]interface{}{},
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Description: "List of objects",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/apimachinery/pkg/runtime.RawExtension"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "k8s.io/apimachinery/pkg/runtime.RawExtension"},
	}
}

func schema_pkg_apis_meta_v1_ListMeta(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"selfLink": {
						SchemaProps: spec.SchemaProps{
							Description: "Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"resourceVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"continue": {
						SchemaProps: spec.SchemaProps{
							Description: "continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"remainingItemCount": {
						SchemaProps: spec.SchemaProps{
							Description: "remainingItemCount is the number of subsequent items in the list which are not included in this list response. If the list request contained label or field selectors, then the number of remaining items is unknown and the field will be left unset and omitted during serialization. If the list is complete (either because it is not chunking or because this is the last chunk), then there are no more remaining items and this field will be left unset and omitted during serialization. Servers older than v1.15 do not set this field. The intended use of the remainingItemCount is *estimating* the size of a collection. Clients should not rely on the remainingItemCount to be set or to be exact.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_ListOptions(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ListOptions is the query options to a standard REST list call.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"labelSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"fieldSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"watch": {
						SchemaProps: spec.SchemaProps{
							Description: "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"allowWatchBookmarks": {
						SchemaProps: spec.SchemaProps{
							Description: "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"resourceVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"resourceVersionMatch": {
						SchemaProps: spec.SchemaProps{
							Description: "resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.\n\nDefaults to unset",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"timeoutSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"limit": {
						SchemaProps: spec.SchemaProps{
							Description: "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"continue": {
						SchemaProps: spec.SchemaProps{
							Description: "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"sendInitialEvents": {
						SchemaProps: spec.SchemaProps{
							Description: "`sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.\n\nWhen `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan\n  is interpreted as \"data at least as new as the provided `resourceVersion`\"\n  and the bookmark event is send when the state is synced\n  to a `resourceVersion` at least as fresh as the one provided by the ListOptions.\n  If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the\n  bookmark event is send when the state is synced at least to the moment\n  when request started being processed.\n- `resourceVersionMatch` set to any other value or unset\n  Invalid error is returned.\n\nDefaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_ManagedFieldsEntry(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"manager": {
						SchemaProps: spec.SchemaProps{
							Description: "Manager is an identifier of the workflow managing these fields.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"operation": {
						SchemaProps: spec.SchemaProps{
							Description: "Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the version of this resource that this field set applies to. The format is \"group/version\" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"time": {
						SchemaProps: spec.SchemaProps{
							Description: "Time is the timestamp of when the ManagedFields entry was added. The timestamp will also be updated if a field is added, the manager changes any of the owned fields value or removes a field. The timestamp does not update when a field is removed from the entry because another manager took it over.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"fieldsType": {
						SchemaProps: spec.SchemaProps{
							Description: "FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: \"FieldsV1\"",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"fieldsV1": {
						SchemaProps: spec.SchemaProps{
							Description: "FieldsV1 holds the first JSON version format as described in the \"FieldsV1\" type.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.FieldsV1"),
						},
					},
					"subresource": {
						SchemaProps: spec.SchemaProps{
							Description: "Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.FieldsV1", "k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_pkg_apis_meta_v1_MicroTime(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "MicroTime is version of Time with microsecond level precision.",
				Type:        v1.MicroTime{}.OpenAPISchemaType(),
				Format:      v1.MicroTime{}.OpenAPISchemaFormat(),
			},
		},
	}
}

func schema_pkg_apis_meta_v1_ObjectMeta(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"generateName": {
						SchemaProps: spec.SchemaProps{
							Description: "GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\n\nIf this field is specified and the generated name exists, the server will return a 409.\n\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"namespace": {
						SchemaProps: spec.SchemaProps{
							Description: "Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \"default\" namespace, but \"default\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\n\nMust be a DNS_LABEL. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"selfLink": {
						SchemaProps: spec.SchemaProps{
							Description: "Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"uid": {
						SchemaProps: spec.SchemaProps{
							Description: "UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\n\nPopulated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"resourceVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\n\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"generation": {
						SchemaProps: spec.SchemaProps{
							Description: "A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"creationTimestamp": {
						SchemaProps: spec.SchemaProps{
							Description: "CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.\n\nPopulated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"deletionTimestamp": {
						SchemaProps: spec.SchemaProps{
							Description: "DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested.\n\nPopulated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"deletionGracePeriodSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"labels": {
						SchemaProps: spec.SchemaProps{
							Description: "Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"annotations": {
						SchemaProps: spec.SchemaProps{
							Description: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"ownerReferences": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"uid",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "uid",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.OwnerReference"),
									},
								},
							},
						},
					},
					"finalizers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type":      "set",
								"x-kubernetes-patch-strategy": "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"managedFields": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like \"ci-cd\". The set of fields is always in the version that the workflow used when modifying the object.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ManagedFieldsEntry"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ManagedFieldsEntry", "k8s.io/apimachinery/pkg/apis/meta/v1.OwnerReference", "k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_pkg_apis_meta_v1_OwnerReference(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "API version of the referent.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"uid": {
						SchemaProps: spec.SchemaProps{
							Description: "UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"controller": {
						SchemaProps: spec.SchemaProps{
							Description: "If true, this reference points to the managing controller.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"blockOwnerDeletion": {
						SchemaProps: spec.SchemaProps{
							Description: "If true, AND if the owner has the \"foregroundDeletion\" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion for how the garbage collector interacts with this field and enforces the foreground deletion. Defaults to false. To set this field, a user needs \"delete\" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
				Required: []string{"apiVersion", "kind", "name", "uid"},
			},
			VendorExtensible: spec.VendorExtensible{
				Extensions: spec.Extensions{
					"x-kubernetes-map-type": "atomic",
				},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_PartialObjectMetadata(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PartialObjectMetadata is a generic representation of any object with ObjectMeta. It allows clients to get access to a particular ObjectMeta schema without knowing the details of the version.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
							Default:     map[string]interface{}{},
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_pkg_apis_meta_v1_PartialObjectMetadataList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PartialObjectMetadataList contains a list of objects containing only their metadata",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Default:     map[string]interface{}{},
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Description: "items contains each of the included items.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.PartialObjectMetadata"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "k8s.io/apimachinery/pkg/apis/meta/v1.PartialObjectMetadata"},
	}
}

func schema_pkg_apis_meta_v1_Patch(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Patch is provided to give a concrete name and type to the Kubernetes PATCH request body.",
				Type:        []string{"object"},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_PatchOptions(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PatchOptions may be provided when patching an API object. PatchOptions is meant to be a superset of UpdateOptions.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"dryRun": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"force": {
						SchemaProps: spec.SchemaProps{
							Description: "Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"fieldManager": {
						SchemaProps: spec.SchemaProps{
							Description: "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"fieldValidation": {
						SchemaProps: spec.SchemaProps{
							Description: "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_Preconditions(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"uid": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the target UID.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"resourceVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the target ResourceVersion",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_RootPaths(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RootPaths lists the paths available at root. For example: \"/healthz\", \"/apis\".",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"paths": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "paths are the paths available at root.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
				Required: []string{"paths"},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_ServerAddressByClientCIDR(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ServerAddressByClientCIDR helps the client to determine the server address that they should use, depending on the clientCIDR that they match.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"clientCIDR": {
						SchemaProps: spec.SchemaProps{
							Description: "The CIDR with which clients can match their IP to figure out the server address that they should use.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"serverAddress": {
						SchemaProps: spec.SchemaProps{
							Description: "Address of this server, suitable for a client that matches the above CIDR. This can be a hostname, hostname:port, IP or IP:port.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"clientCIDR", "serverAddress"},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_Status(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Status is a return value for calls that don't return other objects.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Default:     map[string]interface{}{},
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Description: "Status of the operation. One of: \"Success\" or \"Failure\". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"message": {
						SchemaProps: spec.SchemaProps{
							Description: "A human-readable description of the status of this operation.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"reason": {
						SchemaProps: spec.SchemaProps{
							Description: "A machine-readable description of why this operation is in the \"Failure\" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"details": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.StatusDetails"),
						},
					},
					"code": {
						SchemaProps: spec.SchemaProps{
							Description: "Suggested HTTP return code for this status, 0 if not set.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "k8s.io/apimachinery/pkg/apis/meta/v1.StatusDetails"},
	}
}

func schema_pkg_apis_meta_v1_StatusCause(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "StatusCause provides more information about an api.Status failure, including cases when multiple errors are encountered.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"reason": {
						SchemaProps: spec.SchemaProps{
							Description: "A machine-readable description of the cause of the error. If this value is empty there is no information available.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"message": {
						SchemaProps: spec.SchemaProps{
							Description: "A human-readable description of the cause of the error.  This field may be presented as-is to a reader.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"field": {
						SchemaProps: spec.SchemaProps{
							Description: "The field of the resource that has caused this error, as named by its JSON serialization. May include dot and postfix notation for nested attributes. Arrays are zero-indexed.  Fields may appear more than once in an array of causes due to fields having multiple errors. Optional.\n\nExamples:\n  \"name\" - the field \"name\" on the current resource\n  \"items[0].name\" - the field \"name\" on the first array entry in \"items\"",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_StatusDetails(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "StatusDetails is a set of additional properties that MAY be set by the server to provide additional information about a response. The Reason field of a Status object defines what attributes will be set. Clients must ignore fields that do not match the defined type of each attribute, and should assume that any attribute may be empty, invalid, or under defined.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"group": {
						SchemaProps: spec.SchemaProps{
							Description: "The group attribute of the resource associated with the status StatusReason.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "The kind attribute of the resource associated with the status StatusReason. On some operations may differ from the requested resource Kind. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"uid": {
						SchemaProps: spec.SchemaProps{
							Description: "UID of the resource. (when there is a single resource which can be described). More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"causes": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.StatusCause"),
									},
								},
							},
						},
					},
					"retryAfterSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the time in seconds before the operation should be retried. Some errors may indicate the client must take an alternate action - for those errors this field may indicate how long to wait before taking the alternate action.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.StatusCause"},
	}
}

func schema_pkg_apis_meta_v1_Table(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Table is a tabular representation of a set of API resources. The server transforms the object into a set of preferred columns for quickly reviewing the objects.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Default:     map[string]interface{}{},
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"columnDefinitions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "columnDefinitions describes each column in the returned items array. The number of cells per row will always match the number of column definitions.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.TableColumnDefinition"),
									},
								},
							},
						},
					},
					"rows": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "rows is the list of items in the table.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.TableRow"),
									},
								},
							},
						},
					},
				},
				Required: []string{"columnDefinitions", "rows"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "k8s.io/apimachinery/pkg/apis/meta/v1.TableColumnDefinition", "k8s.io/apimachinery/pkg/apis/meta/v1.TableRow"},
	}
}

func schema_pkg_apis_meta_v1_TableColumnDefinition(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "TableColumnDefinition contains information about a column returned in the Table.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "name is a human readable name for the column.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "type is an OpenAPI type definition for this column, such as number, integer, string, or array. See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for more.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"format": {
						SchemaProps: spec.SchemaProps{
							Description: "format is an optional OpenAPI type modifier for this column. A format modifies the type and imposes additional rules, like date or time formatting for a string. The 'name' format is applied to the primary identifier column which has type 'string' to assist in clients identifying column is the resource name. See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for more.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"description": {
						SchemaProps: spec.SchemaProps{
							Description: "description is a human readable description of this column.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"priority": {
						SchemaProps: spec.SchemaProps{
							Description: "priority is an integer defining the relative importance of this column compared to others. Lower numbers are considered higher priority. Columns that may be omitted in limited space scenarios should be given a higher priority.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
				Required: []string{"name", "type", "format", "description", "priority"},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_TableOptions(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "TableOptions are used when a Table is requested by the caller.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"includeObject": {
						SchemaProps: spec.SchemaProps{
							Description: "includeObject decides whether to include each object along with its columnar information. Specifying \"None\" will return no object, specifying \"Object\" will return the full object contents, and specifying \"Metadata\" (the default) will return the object's metadata in the PartialObjectMetadata kind in version v1beta1 of the meta.k8s.io API group.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_TableRow(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "TableRow is an individual row in a table.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"cells": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "cells will be as wide as the column definitions array and may contain strings, numbers (float64 or int64), booleans, simple maps, lists, or null. See the type field of the column definition for a more detailed description.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Type:   []string{"object"},
										Format: "",
									},
								},
							},
						},
					},
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "conditions describe additional status of a row that are relevant for a human user. These conditions apply to the row, not to the object, and will be specific to table output. The only defined condition type is 'Completed', for a row that indicates a resource that has run to completion and can be given less visual priority.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.TableRowCondition"),
									},
								},
							},
						},
					},
					"object": {
						SchemaProps: spec.SchemaProps{
							Description: "This field contains the requested additional information about each object based on the includeObject policy when requesting the Table. If \"None\", this field is empty, if \"Object\" this will be the default serialization of the object for the current API version, and if \"Metadata\" (the default) will contain the object metadata. Check the returned kind and apiVersion of the object before parsing. The media type of the object will always match the enclosing list - if this as a JSON table, these will be JSON encoded objects.",
							Ref:         ref("k8s.io/apimachinery/pkg/runtime.RawExtension"),
						},
					},
				},
				Required: []string{"cells"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.TableRowCondition", "k8s.io/apimachinery/pkg/runtime.RawExtension"},
	}
}

func schema_pkg_apis_meta_v1_TableRowCondition(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "TableRowCondition allows a row to be marked with additional information.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type of row condition. The only defined value is 'Completed' indicating that the object this row represents has reached a completed state and may be given less visual priority than other rows. Clients are not required to honor any conditions but should be consistent where possible about handling the conditions.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Description: "Status of the condition, one of True, False, Unknown.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"reason": {
						SchemaProps: spec.SchemaProps{
							Description: "(brief) machine readable reason for the condition's last transition.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"message": {
						SchemaProps: spec.SchemaProps{
							Description: "Human readable message indicating details about last transition.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"type", "status"},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_Time(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.",
				Type:        v1.Time{}.OpenAPISchemaType(),
				Format:      v1.Time{}.OpenAPISchemaFormat(),
			},
		},
	}
}

func schema_pkg_apis_meta_v1_Timestamp(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Timestamp is a struct that is equivalent to Time, but intended for protobuf marshalling/unmarshalling. It is generated into a serialization that matches Time. Do not use in Go structs.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"seconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"nanos": {
						SchemaProps: spec.SchemaProps{
							Description: "Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
				Required: []string{"seconds", "nanos"},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_TypeMeta(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "TypeMeta describes an individual object in an API response or request with strings representing the type of the object and its API schema version. Structures that are versioned or persisted should inline TypeMeta.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_UpdateOptions(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "UpdateOptions may be provided when updating an API object. All fields in UpdateOptions should also be present in PatchOptions.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"dryRun": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"fieldManager": {
						SchemaProps: spec.SchemaProps{
							Description: "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"fieldValidation": {
						SchemaProps: spec.SchemaProps{
							Description: "fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_meta_v1_WatchEvent(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Event represents a single event to a watched resource.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"object": {
						SchemaProps: spec.SchemaProps{
							Description: "Object is:\n * If Type is Added or Modified: the new state of the object.\n * If Type is Deleted: the state of the object immediately before deletion.\n * If Type is Error: *Status is recommended; other types may make sense\n   depending on context.",
							Ref:         ref("k8s.io/apimachinery/pkg/runtime.RawExtension"),
						},
					},
				},
				Required: []string{"type", "object"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/runtime.RawExtension"},
	}
}

func schema_k8sio_apimachinery_pkg_runtime_RawExtension(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RawExtension is used to hold extensions in external versions.\n\nTo use this, make a field which has RawExtension as its type in your external, versioned struct, and Object in your internal struct. You also need to register your various plugin types.\n\n// Internal package:\n\n\ttype MyAPIObject struct {\n\t\truntime.TypeMeta `json:\",inline\"`\n\t\tMyPlugin runtime.Object `json:\"myPlugin\"`\n\t}\n\n\ttype PluginA struct {\n\t\tAOption string `json:\"aOption\"`\n\t}\n\n// External package:\n\n\ttype MyAPIObject struct {\n\t\truntime.TypeMeta `json:\",inline\"`\n\t\tMyPlugin runtime.RawExtension `json:\"myPlugin\"`\n\t}\n\n\ttype PluginA struct {\n\t\tAOption string `json:\"aOption\"`\n\t}\n\n// On the wire, the JSON will look something like this:\n\n\t{\n\t\t\"kind\":\"MyAPIObject\",\n\t\t\"apiVersion\":\"v1\",\n\t\t\"myPlugin\": {\n\t\t\t\"kind\":\"PluginA\",\n\t\t\t\"aOption\":\"foo\",\n\t\t},\n\t}\n\nSo what happens? Decode first uses json or yaml to unmarshal the serialized data into your external MyAPIObject. That causes the raw JSON to be stored, but not unpacked. The next step is to copy (using pkg/conversion) into the internal struct. The runtime package's DefaultScheme has conversion functions installed which will unpack the JSON stored in RawExtension, turning it into the correct object type, and storing it in the Object. (TODO: In the case where the object is of an unknown type, a runtime.Unknown object will be created and stored.)",
				Type:        []string{"object"},
			},
		},
	}
}

func schema_k8sio_apimachinery_pkg_runtime_TypeMeta(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "TypeMeta is shared by all top level objects. The proper way to use it is to inline it in your type, like this:\n\n\ttype MyAwesomeAPIObject struct {\n\t     runtime.TypeMeta    `json:\",inline\"`\n\t     ... // other fields\n\t}\n\nfunc (obj *MyAwesomeAPIObject) SetGroupVersionKind(gvk *metav1.GroupVersionKind) { metav1.UpdateTypeMeta(obj,gvk) }; GroupVersionKind() *GroupVersionKind\n\nTypeMeta is provided here for convenience. You may use it directly from this package or define your own with the same fields.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"kind": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
			},
		},
	}
}

func schema_k8sio_apimachinery_pkg_runtime_Unknown(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Unknown allows api objects with unknown types to be passed-through. This can be used to deal with the API objects from a plug-in. Unknown objects still have functioning TypeMeta features-- kind, version, etc. metadata and field mutatation.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"kind": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"ContentEncoding": {
						SchemaProps: spec.SchemaProps{
							Description: "ContentEncoding is encoding used to encode 'Raw' data. Unspecified means no encoding.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"ContentType": {
						SchemaProps: spec.SchemaProps{
							Description: "ContentType  is serialization method used to serialize 'Raw'. Unspecified means ContentTypeJSON.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"ContentEncoding", "ContentType"},
			},
		},
	}
}

func schema_k8sio_apimachinery_pkg_version_Info(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Info contains versioning information. how we'll want to distribute that information.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"major": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"minor": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"gitVersion": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"gitCommit": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"gitTreeState": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"buildDate": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"goVersion": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"compiler": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"platform": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
				},
				Required: []string{"major", "minor", "gitVersion", "gitCommit", "gitTreeState", "buildDate", "goVersion", "compiler", "platform"},
			},
		},
	}
}
